---
uuid: "5d2a083c-a623-460a-9cfc-77666376e598"
title: 经典数据结构・单向链表
date: 2021-07-11
category: 学习
---

# 定义

In order to avoid the linear cost of insertion and deletion, we need to ensure that the list is not stored contiguously.

The linked list consists of a series of structures, each of them contains the element and a pointer to a structure containing its successor.

头文件：

```c
#ifndef _LINKED_LIST_H
#define _LINKED_LIST_H

#include <assert.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

#define element_type int64_t

struct node;
typedef struct node *list;
typedef struct node *position;

typedef struct node {
  element_type element;
  struct node *next;
} node;

int is_empty(list);
int is_last(position, list);

position find_element(element_type, list);
void delete_element(element_type, list);
position insert_element(element_type, position);

size_t delete_list(list);
list init_list(element_type);

#endif
```

# 实现

## 检测链表是否为空

```c
/* return 1 if list l is empty */
int is_empty(list l) { return l->next == NULL; }
```

## 检验是否是最后一个元素

```c
/* return 1 if position p is the last element in list */
int is_last(position p, list l) { return p->next == NULL; }
```

## 寻找元素

寻找第一个匹配元素的位置，返回 `NULL` 如果没有找到。

```c
position find_element(element_type element, list l) {
  position p = l->next;
  while (p != NULL && p->element != element) {
    p = p->next;
  }
  return p;
}
```

## 删除元素

删除第一个匹配的元素，需要首先寻找到这个元素的前一个元素。

```c
void delete_element(element_type element, list l) {
  position p = l;
  while (p->next != NULL && p->next->element != element) {
    p = p->next;
  }
  if (!is_last(p, l)) {
    position tmp = p->next;
    p->next = tmp->next;
    free(tmp);
  }
}
```

## 插入元素

在指定的位置插入元素

```c
position insert_element(element_type element, position p) {
  position tmp = malloc(sizeof(struct node));
  assert(tmp != NULL);
  tmp->next = p->next;
  tmp->element = element;
  p->next = tmp;
  return tmp;
}
```

## 清空链表

```c
size_t delete_list(list l) {
  size_t total = 1;
  position p, tmp;
  p = l->next;
  l->next = NULL;
  while (p != NULL) {
    tmp = p->next;
    free(p);
    p = tmp;
    total++;
  }
  return total;
}
```

## 创建链表头

```c
list init_list(element_type element) {
  position cell = malloc(sizeof(struct node));
  assert(cell != NULL);
  cell->next = NULL;
  cell->element = element;
  return cell;
}
```

# 测试例

编译命令：`clang -Og linked_list.c test.c`

```c
#include "linked_list.h"

void use_list(list l) {
  size_t count = 0;
  while (l->next != NULL) {
    l = l->next;
    count++;
  }
  find_element(114514, l);
}

int main() {
  list numbers = init_list(1024);
  position pos = numbers;
  for (size_t i = 0; i < 51200000; i++) 
    pos = insert_element(i * 10, pos);
  use_list(numbers);
  delete_list(numbers);
  return 0;
}
```

[下载源码](./assets/linked_list.tar.gz)