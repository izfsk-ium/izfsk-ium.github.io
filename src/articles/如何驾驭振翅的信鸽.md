---
uuid: "194287c0-77bd-493c-92b1-a6ff04c8bf1c"
title: "如何驾驭振翅的信鸽"
subtitle: "在 Flutter 中使用 Pigeon"
english: "The-Ride-Of-Fluttering-Pigeon"
date: 2023-09-21
category: "学习"
outdated: false
draft: false
ref: 
  - name: "Writing custom platform-specific code"
    url: "https://docs.flutter.dev/platform-integration/platform-channels"
  - name: "pigeon 11.0.1"
    url: "https://pub.dev/packages/pigeon"
  - name: "Pigeon Examples"
    url: "https://github.com/flutter/packages/blob/main/packages/pigeon/example/README.md"
  - name: "Working with native elements in Flutter"
    url: "https://blog.codemagic.io/working-with-native-elements/"
  - name: "Call Flutter Function from Android"
    url: "https://stackoverflow.com/questions/55520563/call-flutter-function-from-android-part-of-the-app"

---

原谅我使用这个似乎不可能正确地得到 SEO 优化的标题，但是「在 Flutter 中使用 Pigeon」这个主题确实很能让人联想到一只扑腾的鸽子......总之，这篇文章主要是我探索在 Flutter 中和原生接口互相调用的一些小结，主要记载的就是「Pigeon 到底怎么用」。

首先盗一张图：

![platform channel](https://docs.flutter.dev/assets/images/docs/PlatformChannels.png)

在 Flutter 中调用原生 API 主要使用的是「平台通道」(Platform Channel)，其起到沟通两个平台的功用，消息和响应以异步的形式进行传递。用最原始的方法来调用平台 API 需要自己写一堆 MethodChannel 代码，这种方法的教程[官方](https://flutter.cn/docs/development/platform-integration/platform-channels#example)写的很清楚了。而对于更复杂的项目，就需要用到代码生成器，类似于用 JSON 需要 json_serializable 和 json_annotation 等代码生成器一样。为了以结构化类型安全方式发送消息，就需要用到 Pigeon 作为 MethodChannel 的替代品。

创建 flutter 应用模版不赘述，添加 pigeon 使用命令 `dart pub add --dev pigeon`。

## 总体步骤

使用 Piegon 的工作流程是这样的：

- 首先，需要定义一个或者多个接口文件，告诉信鸽「对面都有些啥 API 可以用」和/或「自己这边都有些啥 API 可以用」
- 接下来使用代码生成器生成，帮两边都生成模版代码。如果接口文件里面说「对面 Kotlin 有啥啥 API」，那么生成的 Kotlin 代码就带有对应的 Kotlin Interface 需要去实现，生成的 Dart 代码就有可以直接使用的翻译过来的 API。
- 然后，光有定义还不够，Flutter 这边知道对面有了啥 API，那对面还需要实现这些 API 才行。
- 最后在 Flutter 中调用，别忘了这些调用都是**异步**的。

## 从 Flutter 调用 Kotlin 接口

这里一步一步来实现「从 Flutter 调用一个名为 `getAndroidVersion` 的 Kotlin API 并把返回值显示在屏幕上」：

### 定义接口文件

在项目根目录创建新的目录 `piegons`，然后输入对面 API 的签名描述：

```dart
import 'package:pigeon/pigeon.dart';

@HostApi()
@ConfigurePigeon(PigeonOptions(
  dartOut: 'lib/api.dart',
  dartOptions: DartOptions(),
  kotlinOut:
      'android/app/src/main/kotlin/com/example/pigeon_test/AndroidApi.kt',
  kotlinOptions: KotlinOptions(),
  dartPackageName: 'com.example.pigeon_test',
))
abstract class AndroidAPI {
  String getAndroidVersion(bool longFormat);
}
```

其中：

1. `@HostApi()` 指明这是原生 API，也就是「会从 Flutter 中调用的 API」。相应的，如果是反过来调用，就是 `@FlutterApi()`。
2. `@ConfigurePigeon` 注解配置生成的文件都要保存在什么位置。这些参数也可以用命令行指定。假如有很多个 abstract class，这个注解只需要放在最后一个上就可以了。
3. `abstract class` 内的定义就是 API 的定义了。这也是之后直接在 Flutter 中使用的函数名称。

### 运行代码生成器

在终端中运行：

```bash
-> % dart run pigeon --input pigeons/api.dart
```

很快就会新增两个文件：

1. `'lib/api.dart'` 是生成的 dart 绑定，**无须关心这个文件，就当它不存在即可**，它的作用是自动实现 abstract class 让你能够调用上面的 `AndroidAPI.getAndroidVersion`
2. `AndroidApi.kt` 是生成的 Kotlin 接口文件，这也是下一步你需要实现的平台方法的接口。

### 实现 Kotlin 接口

打开 Android Studio，趁着它忙活你可以先上个厕所，然后首先打开 MainActivity.kt，开始实现相应的接口。前面指定的接口名字是 `AndroidAPI`,所以不管是 Kotlin 这边还是 Flutter 那边都是这个名字：

```kotlin
class AndroidAPIImpl : AndroidAPI {
    override fun getAndroidVersion(longFormat: Boolean): String {
        return if (!longFormat){
            "Kernel: " + System.getProperty("os.version")
        }else {
            """Kernel: ${System.getProperty("os.version")}(${Build.VERSION.INCREMENTAL})
            OS API Level: ${Build.VERSION.SDK_INT}
            Device: ${Build.DEVICE}
            Model / Product): ${Build.MODEL} / (${Build.PRODUCT})"""
        }
    }
}
```

### 初始化

如果此时运行，在调用时只会出现 `PlatformException: channel-error`，因为光是实现了接口，还没有「注册」上去，所以需要在 MainActivity 中做一些修改：

```kotlin
class MainActivity: FlutterActivity() {
    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        val api = AndroidAPIImpl()
        AndroidAPI.setUp(
            binaryMessenger = flutterEngine.dartExecutor.binaryMessenger,
            api = api
        );
    }
}
```

就是说需要一个实例化的 API 类并把它和 Flutter 引擎连接起来才行。

### 在 Flutter 中调用

无须多论，只要注意调用是异步的就可以：

```dart
...
ElevatedButton(
    onPressed: () async {
      final result = await AndroidAPI().getAndroidVersion(false);
      setState(() {
        data = result.toString();
      });
    },
    child: const Text("Android 版本(短)")),
ElevatedButton(
    onPressed: () async {
      final result = await AndroidAPI().getAndroidVersion(true);
      setState(() {
        data = result;
      });
    },
    child: const Text("Android 版本(长)")),
...
```

<figure style="align-items: center;display: flex;justify-content: center;flex-direction: column;">
    <img src="./assets/screen.png" alt="结果" style="width: auto;">
    <figcaption aria-hidden="true">结果</figcaption>
</figure>

### 其他例子

上图还有一些其他的函数，以下是完整的实现：

#### 声明文件

```dart
import 'package:pigeon/pigeon.dart';

class CustomDataInfo {
  int? pid;
  int? ppid;
  int? uid;
  String? androidVersion;
}

@HostApi()
@ConfigurePigeon(PigeonOptions(
  // same as before
))
abstract class AndroidAPI {
  String getAndroidVersion(bool longFormat);

  @async
  CustomDataInfo getData();

  List<int?> fib(int n);
}
```

注意异步函数使用 @async 注解而不是正常的 async 函数写法。另外泛型类型参数必须可为 null (带个问号)。

#### Kotlin 的实现

```kotlin
class AndroidAPIImpl : AndroidAPI{
    override fun getAndroidVersion(longFormat: Boolean): String {
        // same as before
    }

    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)
    override fun getData(callback: (Result<CustomDataInfo>) -> Unit) {
        callback(Result.success(
           CustomDataInfo(
               pid = Os.getpid().toLong(),
               ppid = Os.getppid().toLong(),
               uid = Os.getuid().toLong(),
               androidVersion = getAndroidVersion(longFormat = false),
           )
        ));
    }

    override fun fib(n: Long): List<Long?> {
        if (n <= 0){ throw FlutterError("Less than Zero"); }
        val list = mutableListOf(0L, 1L)
        for (i in 2..n) {
            list.add(list[(i - 1).toInt()] + list[(i - 2).toInt()])
        }
        return list
    }
}
```

## 从 Kotlin 调用 Flutter 接口

反过来调用也是可以的，就是「从 Kotlin 中调用 Flutter 代码」。总体来讲步骤是相同的。首先，需要定义接口：

```dart
@FlutterApi()
@ConfigurePigeon(PigeonOptions(
  // same
))
abstract class MessageFlutterApi {
  String getFlutterVersion();
}
```

注意这个 `@FlutterApi()` 是不同点。接下来运行代码生成器，同样是生成两个文件。不过这回两边都要改动。我们的验证方法如下：先从 Flutter 端调用 `callMeInKotlin` 方法告诉 Kotlin 端「快来调用我！」，接着 Kotlin 端调用 Flutter 端方法 `getFlutterVersion`，并把从 Flutter 那边得到的结果再传回去显示在屏幕上。

```dart
ElevatedButton(
  onPressed: () async {
    final result = await AndroidAPI().callMeInKotlin();
    setState(() {
      data = result;
    });
  },
  child: const Text("Kotlin 端调用 Flutter 方法"))
```

接着实现 Flutter 端的方法供 Kotlin 调用，**需要 implements MessageFlutterApi**，这里取个巧：

```dart
class _MyHomePageState extends State<MyHomePage> implements MessageFlutterApi {
  // ......
  @override
  String getFlutterVersion() {
    debugPrint("Call from kotlin");
    return "Flutter 3.13.2 • channel stable";
  }

  void calledFromKotlin() {
    setState(() {
      data = "Flutter 3.13.2 • channel stable";
    });
  }
}
```

Kotlin 端对 `callMeInKotlin` 实现，但是，这一回需要另外一个绑定：

```kotlin
// MainActivity
var flutterApi: MessageFlutterApi? = null

class MainActivity: FlutterActivity() {
    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        val api = AndroidAPIImpl()
        flutterApi = MessageFlutterApi(flutterEngine.dartExecutor.binaryMessenger);
        AndroidAPI.setUp(
            binaryMessenger = flutterEngine.dartExecutor.binaryMessenger,
            api = api
        );
    }
}

// AndroidAPIImpl

class AndroidAPIImpl : AndroidAPI{
  override fun callMeInKotlin(callback: (Result<String>) -> Unit) {
      flutterApi!!.getFlutterVersion(fun(it: String) {
          println("Data received from Flutter : $it")
          callback(Result.success("Data received from Flutter and processed by Kotlin !"));
      })
  }
}
```

最后得到的结果是在屏幕显示 "Data received from Flutter and processed by Kotlin !"，终端的显示是：

```java
✓  Built build/app/outputs/flutter-apk/app-debug.apk.
Connecting to VM Service at ws://127.0.0.1:38449/RQ5ft1v3X0k=/ws
I/Gralloc4(11614): Adding additional valid usage bits: 0x546c08202000
I/flutter (11614): Call from kotlin
I/System.out(11614): Data received from Flutter : Flutter 3.13.2 • channel stable
```

## 一个复杂的例子

来结合 `pgppainless-core` 库实现一个 PGP 密钥串生成的功能。

### 添加库

在 `gradle.properties` 中添加库并 Sync：

```gradle
dependencies {
    implementation "org.pgpainless:pgpainless-core:1.6.2"
}
```

### 实现

接口：

```dart
import 'package:pigeon/pigeon.dart';

class KeyPair {
  String? pubkey;
  String? prikey;
}

@HostApi()
abstract class AndroidAPI {
  KeyPair generateKeyPair();
}
```

实现：

```kotlin
class AndroidAPIImpl : AndroidAPI {
    override fun generateKeyPair(): KeyPair {
        val secretKeys = PGPainless.generateKeyRing()
            .modernKeyRing("Romeo <romeo@montague.lit>", "thisIsAPassword")
        return  KeyPair(
            pubkey = PGPainless.asciiArmor(PGPainless.extractCertificate(secretKeys)),
            prikey = PGPainless.asciiArmor(secretKeys)
        )
    }
}
```

使用：

```dart
class _MyHomePageState extends State<MyHomePage> {
  String pub = "";
  String pri = "";

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Padding(padding: const EdgeInsets.all(20),child: ListView(
        children: [
          Text(pub),
          Text(pri),
          const Divider(),
          ElevatedButton(onPressed: () async {
            final result = await AndroidAPI().generateKeyPair();
            setState(() {
              pub = result.pubkey ?? ""; pri = result.prikey ?? "";
            });
          }, child: const Text("Click to generate key pair"))
        ],
      ),)
    );
  }
}
```

最终结果：

<figure style="align-items: center;display: flex;justify-content: center;flex-direction: column;width: 75%;">
    <img src="./assets/111111111111.gif" alt="结果" style="width: auto;">
    <figcaption aria-hidden="true">结果</figcaption>
</figure>
