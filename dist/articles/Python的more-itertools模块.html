<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="" >

<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
      <meta name="dcterms.date" content="2022-12-08" />
        <title>Python的more-itertools模块</title>
    <link rel="stylesheet" href="/resources/css/article/theme.css" />
    <link rel="stylesheet" href="/resources/css/article/code.css" />
      
  
<style>
@font-face {
  font-family: CONTENT;
  src: url('/resources/fonts/subsets/FT426704c4-a51f-470c-a9c9-f3e3ecc43bfc.woff2') format('woff2'),
       url('/resources/fonts/subsets/FT426704c4-a51f-470c-a9c9-f3e3ecc43bfc.ttf') format('truetype');
}
</style>
  

  <script src="/resources/js/article.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.11.3/viewer.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.11.3/viewer.css" />
</head>

<body>
  <progress id="content_progress" value="0"></progress>

  
  <header>
    <h1 class="title">Python的more-itertools模块</h1>
    <!-- Subtitle -->
        <h3 class="subtitle">&nbsp;</h3>
      </header>

    <nav id="TOC" role="doc-toc">
    <strong>文章归类:&nbsp;<a href="/pages/category.html#学习">学习</a> </strong>
    <input type="checkbox" id="contents">
    <ul>
    <li><a href="#前提" id="toc-前提">前提</a>
    <ul>
    <li><a href="#迭代器" id="toc-迭代器">迭代器</a></li>
    </ul></li>
    <li><a href="#itertools" id="toc-itertools">itertools</a>
    <ul>
    <li><a href="#accumulate-迭代操作器" id="toc-accumulate-迭代操作器">Accumulate : 迭代操作器</a></li>
    <li><a href="#groupby-数据分类汇总" id="toc-groupby-数据分类汇总">Groupby : 数据分类汇总</a></li>
    <li><a href="#product-全排列" id="toc-product-全排列">Product : 全排列</a></li>
    <li><a href="#pairwise-成双成对藕断丝连" id="toc-pairwise-成双成对藕断丝连">Pairwise : 成双成对，藕断丝连</a></li>
    </ul></li>
    <li><a href="#more_itertools" id="toc-more_itertools">more_itertools</a>
    <ul>
    <li><a href="#一变多系列" id="toc-一变多系列">一变多系列</a>
    <ul>
    <li><a href="#grouper" id="toc-grouper">Grouper</a></li>
    <li><a href="#partition" id="toc-partition">Partition</a></li>
    <li><a href="#divide" id="toc-divide">Divide</a></li>
    <li><a href="#split_xxx-系列" id="toc-split_xxx-系列">Split_XXX 系列</a></li>
    </ul></li>
    <li><a href="#多变一系列" id="toc-多变一系列">多变一系列</a>
    <ul>
    <li><a href="#flatten" id="toc-flatten">Flatten</a></li>
    <li><a href="#collapse" id="toc-collapse">Collapse</a></li>
    <li><a href="#unzip" id="toc-unzip">Unzip</a></li>
    </ul></li>
    <li><a href="#挨个操作系列" id="toc-挨个操作系列">挨个操作系列</a>
    <ul>
    <li><a href="#map_except" id="toc-map_except">Map_except</a></li>
    <li><a href="#map_reduce" id="toc-map_reduce">Map_reduce</a></li>
    <li><a href="#numeric_range" id="toc-numeric_range">Numeric_range</a></li>
    </ul></li>
    <li><a href="#过滤器系列" id="toc-过滤器系列">过滤器系列</a>
    <ul>
    <li><a href="#strip-系列" id="toc-strip-系列">Strip 系列</a></li>
    <li><a href="#filter_except" id="toc-filter_except">Filter_except</a></li>
    </ul></li>
    </ul></li>
    <li><a href="#参考" id="toc-参考">参考</a></li>
    </ul>
    <ul>
      <li><a href="#reference">参考链接</a></li>
      <li>&nbsp;</li>
      <li class="tools">
        <span id="backtomain">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-house"
            viewBox="0 0 16 16">
            <path
              d="M8.707 1.5a1 1 0 0 0-1.414 0L.646 8.146a.5.5 0 0 0 .708.708L2 8.207V13.5A1.5 1.5 0 0 0 3.5 15h9a1.5 1.5 0 0 0 1.5-1.5V8.207l.646.647a.5.5 0 0 0 .708-.708L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.707 1.5ZM13 7.207V13.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5V7.207l5-5 5 5Z" />
          </svg>
        </span>
        <span id="larger">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-plus-lg"
            viewBox="0 0 16 16">
            <path fill-rule="evenodd"
              d="M8 2a.5.5 0 0 1 .5.5v5h5a.5.5 0 0 1 0 1h-5v5a.5.5 0 0 1-1 0v-5h-5a.5.5 0 0 1 0-1h5v-5A.5.5 0 0 1 8 2Z" />
          </svg>
        </span>
        <span id="smaller">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-dash-lg"
            viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M2 8a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11A.5.5 0 0 1 2 8Z" />
          </svg>
        </span>
        <span id="switchfont">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-fonts"
            viewBox="0 0 16 16">
            <path
              d="M12.258 3h-8.51l-.083 2.46h.479c.26-1.544.758-1.783 2.693-1.845l.424-.013v7.827c0 .663-.144.82-1.3.923v.52h4.082v-.52c-1.162-.103-1.306-.26-1.306-.923V3.602l.431.013c1.934.062 2.434.301 2.693 1.846h.479L12.258 3z" />
          </svg>
        </span>
        <span id="backtotop">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-bar-up"
            viewBox="0 0 16 16">
            <path fill-rule="evenodd"
              d="M8 10a.5.5 0 0 0 .5-.5V3.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 3.707V9.5a.5.5 0 0 0 .5.5zm-7 2.5a.5.5 0 0 1 .5-.5h13a.5.5 0 0 1 0 1h-13a.5.5 0 0 1-.5-.5z" />
          </svg>
        </span>
      </li>
    </ul>

  </nav>
  
  <main>
    <h1 id="前提">前提</h1>
    <p>所谓程序就是“一定的环境中处理数据”，日常编码中总是会碰到“在一个序列的数据中过滤”和“对序列中的每一个项目操作”这样的需求，我们可以这样做：</p>
    <div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> raw:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i.attribute <span class="op">==</span> <span class="va">True</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        targetA.append(i)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        targetB.append(i)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (index, target) <span class="kw">in</span> <span class="bu">enumerate</span>(targetA):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    targetA <span class="op">=</span> do_something(target)</span></code></pre></div>
    <p>也可以类似Javascript这样:</p>
    <div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">.</span><span class="fu">filter</span>(i <span class="kw">=&gt;</span> i <span class="op">&gt;</span> <span class="dv">2</span>)<span class="op">.</span><span class="fu">map</span>(i <span class="kw">=&gt;</span> i <span class="op">**</span> i)<span class="op">;</span></span></code></pre></div>
    <p>当然，Python虽然提供了<code>map()</code>，<code>filter()</code>函数，但是不能够和JS那样链式调用，不过本文介绍的是比<code>map()</code>，<code>filter()</code>更加强大的函数们。</p>
    <h2 id="迭代器">迭代器</h2>
    <p>简单的来讲，所谓迭代器，就是一个懒加载的列表。有一个指针<code>__next__()</code>指向“目前的项目”，调用这个指针就会“消费掉”这个值。而使用<code>list()</code>就能把整个迭代器变成列表。</p>
    <p>迭代器比列表更加节省内存，因为每一个值会在需要的时候才计算。但是同样的，如果你试图把一个无限的迭代器转list，那就会爆内存。</p>
    <h1 id="itertools">itertools</h1>
    <p><code>itertools</code>是python提供的标准库，包含了许多帮助函数。这些函数的教程网上已经汗牛充栋，这里只提几个：</p>
    <h2 id="accumulate-迭代操作器">Accumulate : 迭代操作器</h2>
    <p>按照字面意思翻译，这个函数应该叫做“累加器”，最基础的使用方法也是累加：</p>
    <div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(itertools.accumulate([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#[1, 3, 6]</span></span></code></pre></div>
    <p>这个函数相当于：</p>
    <div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(itertools.accumulate([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],<span class="kw">lambda</span> x,y:x<span class="op">+</span>y))</span></code></pre></div>
    <p>可以看到这个函数的第二个参数是一个函数。你可以给任意一个“输入两个值输出一个值”的函数，然后一步一步得到它的结果。换成<code>operator.mul</code>就是阶乘（<code>1*2，2*6，6*4......</code>）；换成<code>max</code>就是带过程的取最大值。</p>
    <h2 id="groupby-数据分类汇总">Groupby : 数据分类汇总</h2>
    <p>假如你有这样的数据：</p>
    <div class="sourceCode" id="cb5"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="er">data</span> <span class="er">=</span> <span class="ot">[</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span><span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span> <span class="dt">&quot;data&quot;</span><span class="fu">:</span> <span class="st">&quot;John&quot;</span><span class="fu">}</span><span class="ot">,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span><span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span> <span class="dt">&quot;data&quot;</span><span class="fu">:</span> <span class="st">&quot;Mike&quot;</span><span class="fu">}</span><span class="ot">,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span><span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="dv">2</span><span class="fu">,</span> <span class="dt">&quot;data&quot;</span><span class="fu">:</span> <span class="st">&quot;Jenny&quot;</span><span class="fu">}</span><span class="ot">,</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span><span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="dv">2</span><span class="fu">,</span> <span class="dt">&quot;data&quot;</span><span class="fu">:</span> <span class="st">&quot;Wang&quot;</span><span class="fu">}</span><span class="ot">,</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span><span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="dv">3</span><span class="fu">,</span> <span class="dt">&quot;data&quot;</span><span class="fu">:</span> <span class="st">&quot;August&quot;</span><span class="fu">}</span><span class="ot">,</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">]</span></span></code></pre></div>
    <p>你想拿到这样的结果：</p>
    <div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>[</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;items&quot;</span>: [<span class="st">&quot;John&quot;</span>, <span class="st">&quot;Mike&quot;</span>]},</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">2</span>, <span class="st">&quot;items&quot;</span>: [<span class="st">&quot;Jenny&quot;</span>, <span class="st">&quot;Wang&quot;</span>]},</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;items&quot;</span>: [<span class="st">&quot;August&quot;</span>]},</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
    <p>就可以使用这串魔法：</p>
    <div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>[{<span class="st">&#39;type&#39;</span>:i,<span class="st">&#39;items&#39;</span>:[i[<span class="st">&#39;data&#39;</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">list</span>(j)]} <span class="cf">for</span> i,j <span class="kw">in</span> itertools.groupby(data, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="st">&quot;type&quot;</span>])]</span></code></pre></div>
    <p>其实也不是那么魔法，最重要的就是这一串：</p>
    <p><code>groupby(data, key=lambda x: x["type"])</code></p>
    <p>同样的，groupby函数接收两个参数，一个是迭代器，一个是函数类型，用来指定分类的key。可以理解成SQL<code>SELECT something FROM table GROUP BY key</code>中的<code>key</code>。返回类型是一个二元元组，(这个key，包含这个类别的元素的迭代器)。接下来就可以使用<code>list()</code>来转换了，这也是<code>[i['data'] for i in list(j)]</code>的作用。</p>
    <div class="note blue">
    <table>
    <tbody>
    <tr class="odd">
    <td>ℹ️ groupby 在使用之前<strong>一定</strong>要对数据排序好！</td>
    </tr>
    </tbody>
    </table>
    </div>
    <p>还是看不懂？那就看这个版本吧：</p>
    <div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> <span class="bu">list</span>()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> keyFunction(item):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> item[<span class="st">&quot;type&quot;</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, iterator_of_items <span class="kw">in</span> itertools.groupby(data, key<span class="op">=</span>keyFunction):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    list_of_items_of_this_type <span class="op">=</span> <span class="bu">list</span>(iterator_of_items)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    result.append(</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        {<span class="st">&quot;type&quot;</span>: key, <span class="st">&quot;items&quot;</span>: [i[<span class="st">&quot;data&quot;</span>] <span class="cf">for</span> i <span class="kw">in</span> list_of_items_of_this_type]}</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
    <h2 id="product-全排列">Product : 全排列</h2>
    <p>假如你有’ABCD’和’xy’，你想要得到<code>Ax Ay Bx By Cx Cy Dx Dy</code>的排列组合，那么你就可以使用</p>
    <p><code>product('ABCD', 'xy')</code>来得到。很简单。函数签名是这样的：<code>itertools.product(*iterables, repeat=1)</code>，也就是你可以给出任何数量的迭代器。</p>
    <h2 id="pairwise-成双成对藕断丝连">Pairwise : 成双成对，藕断丝连</h2>
    <p><code>pairwise()</code>的用法很简单：<code>pairwise('ABCDEFG') --&gt; AB BC CD DE EF FG</code></p>
    <p>它的实现方式类似于：</p>
    <div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pairwise(iterable):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># s -&gt; (s0, s1), (s1, s2), (s2, s3), ...</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> tee(iterable, <span class="dv">2</span>)     <span class="co"># 获取两个指针</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">next</span>(b, <span class="va">None</span>)               <span class="co"># 一个指针前移</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">zip</span>(a, b)            <span class="co"># 配对</span></span></code></pre></div>
    <h1 id="more_itertools">more_itertools</h1>
    <p>好，现在进入高阶魔法阶段。这里将会一边介绍用法，一边简单分析源码。准备好：）</p>
    <h2 id="一变多系列">一变多系列</h2>
    <p>输入一个迭代器，返回多个结果的类型。</p>
    <h3 id="grouper">Grouper</h3>
    <p><code>more_itertools.grouper(iterable, n, incomplete='fill', fillvalue=None)</code></p>
    <p>按照给定的长度把一个可迭代类型分组。得到一个迭代器，里面包含指定长度的元组。</p>
    <div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(grouper(<span class="st">&#39;ABCDEF&#39;</span>, <span class="dv">3</span>)) <span class="co"># 得到 [(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;D&#39;, &#39;E&#39;, &#39;F&#39;)]</span></span></code></pre></div>
    <p>不过并不是每一个迭代器都能正好是整除你的<code>n</code>，所以<code>incomplete</code>和<code>fillvalue</code>控制不同的表现。假如你的分组目标是”ABCDEFG”，n=3，那么：</p>
    <div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(grouper(<span class="st">&#39;ABCDEFG&#39;</span>, <span class="dv">3</span>, incomplete<span class="op">=</span><span class="st">&#39;fill&#39;</span>, fillvalue<span class="op">=</span><span class="st">&#39;x&#39;</span>))  </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># [(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;D&#39;, &#39;E&#39;, &#39;F&#39;), (&#39;G&#39;, &#39;x&#39;, &#39;x&#39;)]</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(grouper(<span class="st">&#39;ABCDEFG&#39;</span>, <span class="dv">3</span>, incomplete<span class="op">=</span><span class="st">&#39;ignore&#39;</span>, fillvalue<span class="op">=</span><span class="st">&#39;x&#39;</span>)) </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># [(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), (&#39;D&#39;, &#39;E&#39;, &#39;F&#39;)]</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(grouper(<span class="st">&#39;ABCDEFG&#39;</span>, <span class="dv">3</span>, incomplete<span class="op">=</span><span class="st">&#39;strict&#39;</span>))</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 抛出异常 UnequalIterablesError</span></span></code></pre></div>
    <p>这玩意的实现机制很简单：</p>
    <p>首先，如果你要展开一个iter，可以在它前面使用<code>*</code>号。比如<code>print(*iter([1,2,3]))</code>就会打印出<code>1 2 3</code>。</p>
    <p>首先判断<code>incomplete</code>，如果是<code>ignored</code>，就直接上zip，否则，如果是<code>fill</code>的话，就使用<code>zip_longest(*args, fillvalue=fillvalue)</code>，是<code>strict</code>就使用<code>_zip_equal(*args)</code>。但核心是一样的，以<code>ignored</code>模式为例：</p>
    <div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">zip</span>(<span class="op">*</span>[<span class="bu">iter</span>(target_iterable)] <span class="op">*</span> n)</span></code></pre></div>
    <p>注意到<code>[iter()]*n</code>会创造出一个包含<code>n</code>个迭代器的列表，<strong>其中每一个迭代器的内存地址是一样的</strong>，操作一个就是操作全体！那么：</p>
    <div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>a,b,c<span class="op">=</span>[<span class="bu">iter</span>(<span class="st">&quot;hello!&quot;</span>)]<span class="op">*</span><span class="dv">3</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># a &lt;str_iterator at 0x7fd3b529ecb0&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co"># b &lt;str_iterator at 0x7fd3b529ecb0&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co"># c &lt;str_iterator at 0x7fd3b529ecb0&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(<span class="bu">zip</span>(a,b,c))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># [(&#39;h&#39;, &#39;e&#39;, &#39;l&#39;), (&#39;l&#39;, &#39;o&#39;, &#39;!&#39;)]</span></span></code></pre></div>
    <p>在这里，zip函数第一次取得的并不是<code>h,h,h</code>，而是<code>h,e,l</code>，因为每一次取得，所有三个指针的位置都会向前移动一格。</p>
    <h3 id="partition">Partition</h3>
    <p><code>partition(pred, iterable)</code>：返回两个可迭代元素作为元组，前一个不符合你的条件，后一个符合你的条件。可以用来把一个迭代器一分为二成两个部分，<del>不同意的请站到左边，同意的请站到右边</del>。它的使用就比较普遍了。还记得文章开头的那个例子吗？就可以用这个函数来处理，这里另外举例。</p>
    <div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;John&quot;</span>},</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;Mike&quot;</span>},</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">2</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;Jenny&quot;</span>},</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">2</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;Wang&quot;</span>}</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>is_allowed <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="st">&quot;type&quot;</span>] <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>allowed, forbidden <span class="op">=</span> partition(is_allowed, files)</span></code></pre></div>
    <h3 id="divide">Divide</h3>
    <p>顾名思义，这个函数把一个可迭代序列分割成若干个子迭代器。</p>
    <div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [<span class="st">&quot;first&quot;</span>, <span class="st">&quot;second&quot;</span>, <span class="st">&quot;third&quot;</span>, <span class="st">&quot;fourth&quot;</span>, <span class="st">&quot;fifth&quot;</span>, <span class="st">&quot;sixth&quot;</span>, <span class="st">&quot;seventh&quot;</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>[<span class="bu">list</span>(l) <span class="cf">for</span> l <span class="kw">in</span> divide(<span class="dv">3</span>, data)]</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">#  [[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;], [&#39;fourth&#39;, &#39;fifth&#39;], [&#39;sixth&#39;, &#39;seventh&#39;]]</span></span></code></pre></div>
    <p>函数签名是<code>divide(n, iterable)</code>。其实现为，首先，尝试对<code>iterable</code>进行一个下标操作，通过捕获异常来判断类型：</p>
    <div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    iterable[:<span class="dv">0</span>]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">TypeError</span>:</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    seq <span class="op">=</span> <span class="bu">tuple</span>(iterable)   <span class="co"># 相当于是到元组类型的转换，因为迭代器类型不能取下标</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    seq <span class="op">=</span> iterable          <span class="co"># 原来的输入是可以取下标的类型，例如普通列表</span></span></code></pre></div>
    <p>接着，使用<code>q, r = divmod(len(seq), n)</code>来获取商q和余数r。<code>divmod</code>是一个Python的内置函数，用来同时获得商和余数的元组。然后按照步长<code>n</code>结合q,r截取原来的列表构建结果列表：</p>
    <div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>ret, stop <span class="op">=</span> [], <span class="dv">0</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> stop</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&lt;=</span> r:</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        stop <span class="op">+=</span> q <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        stop <span class="op">+=</span> q</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    ret.append(<span class="bu">iter</span>(seq[start:stop]))</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> ret</span></code></pre></div>
    <p>可以看到总是能够保证得到的结果会是<code>n</code>个迭代器。</p>
    <h3 id="split_xxx-系列">Split_XXX 系列</h3>
    <p>对于字符串，可以使用<code>'hello!world!'.split('!')</code>这样的方法把字符串分割成列表，那自然我们也希望能够对一个可迭代元素这样操作。<code>split_at()</code>函数接收的不是一个字符串而是一个函数，如果序列内的元素返回真，就在这里分割。其函数签名如下：<code>split_at(iterable, pred, maxsplit=-1, keep_separator=False)</code>。其中，<code>pred</code>是判断函数，<code>maxsplit</code>是最多分割次数，<code>keep_separator</code>决定是否保留真元素。</p>
    <div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>[<span class="st">&#39;&#39;</span>.join(i) <span class="cf">for</span> i <span class="kw">in</span> more_itertools.split_at(<span class="st">&#39;hello!world&#39;</span>,<span class="kw">lambda</span> x:x<span class="op">==</span><span class="st">&#39;!&#39;</span>,keep_separator<span class="op">=</span><span class="va">True</span>)]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co"># [&#39;hello&#39;, &#39;!&#39;, &#39;world&#39;]</span></span></code></pre></div>
    <p>库里面还提供了其他几个函数，举例说明。约定<code>raw='aaaAaaaAaaaAaa'</code>，则：</p>
    <table>
    <colgroup>
    <col style="width: 25%" />
    <col style="width: 25%" />
    <col style="width: 25%" />
    <col style="width: 25%" />
    </colgroup>
    <thead>
    <tr class="header">
    <th>函数</th>
    <th>描述</th>
    <th>示例</th>
    <th>结果</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td><code>split_at(iterable, pred, maxsplit=-1, keep_separator=False)</code></td>
    <td>按照指定条件分割序列</td>
    <td><code>list(more_itertools.split_at(raw,lambda x:x=='A'))</code></td>
    <td><code>[['a', 'a', 'a'], ['a', 'a', 'a'], ['a', 'a', 'a'], ['a', 'a']]</code></td>
    </tr>
    <tr class="even">
    <td><code>split_before(iterable, pred, maxsplit=-1)</code></td>
    <td>在返回真的元素之前分割，保留真元素</td>
    <td><code>list(more_itertools.split_before(raw,lambda x:x=='A'))</code></td>
    <td><code>[['a', 'a', 'a'], ['A', 'a', 'a', 'a'], ['A', 'a', 'a', 'a'], ['A', 'a', 'a']]</code></td>
    </tr>
    <tr class="odd">
    <td><code>split_after(iterable, pred, maxsplit=-1)</code></td>
    <td>在返回真的元素之后分割，保留真元素</td>
    <td><code>list(more_itertools.split_after(raw,lambda x:x=='A'))</code></td>
    <td><code>[['a', 'a', 'a', 'A'], ['a', 'a', 'a', 'A'], ['a', 'a', 'a', 'A'], ['a', 'a']]</code></td>
    </tr>
    </tbody>
    </table>
    <p>整个<code>split_xxx</code>系列都有类似的实现。首先判断<code>maxsplit</code>，为0就直接<code>yield list(iterator)</code>。再遍历原来序列的每一个元素，判断并按照要求<code>yield</code>即可：</p>
    <div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> maxsplit <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="bu">list</span>(iterable)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>buf, it <span class="op">=</span> [], <span class="bu">iter</span>(iterable)    <span class="co"># buf 是每一次返回的结果</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> it:</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pred(item):</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> buf</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 其他判断，略</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        buf <span class="op">=</span> []</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        maxsplit <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        buf.append(item)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="cf">yield</span> buf                   <span class="co"># 返回结果，yield返回的依旧是一个生成器</span></span></code></pre></div>
    <p>注意这个函数返回的依旧是一个<strong>generator object</strong>，所以最后使用yield关键字。假如使用<code>split_at('00100',lambda x:x=='1')</code>的话，首先会<code>append</code>两次，把前面两个0放到结果中去，然后遇到1，直接把buf yield出去，下一次再进入时，buf再次被置零为空列表(第一个yield下面一行)再继续操作。最后遍历全部完成，再把剩下的返回。buf就是保存每一次结果的列表。其他split系列的函数实现类似，略有不同。</p>
    <p>有两个函数与众不同，一个是<code>split_when</code>，这个函数接收的条件判断函数需要两个参数，返回真时则在这两个元素之间分割。例如，对输入<code>[1, 2, 3, 3, 2, 5, 2, 4, 2]</code>，判断函数拿到的就是<code>(1,2),(2,3),(3,3)......</code>这样的一组元素。实现上就需要用到双重指针了，一个指向目前项目，一个指向未来(next)项目。</p>
    <div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(split_when([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>], <span class="kw">lambda</span> x, y: x <span class="op">&gt;</span> y))</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># [[1, 2, 3, 3], [2, 5], [2, 4], [2]]</span></span></code></pre></div>
    <p>另外一个是<code>split_into(iterable, sizes)</code>函数，很简单，就是按照sizes指定的大小列表分割：</p>
    <div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(split_into([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>], [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co"># [[1], [2, 3], [4, 5, 6]]</span></span></code></pre></div>
    <p>实现起来相当简单，遍历sizes切分即可，基本上就相当于<code>[list(itertools.islice(iterator,i)) for i in sizes]</code>(所以返回的依旧是迭代器)。</p>
    <h2 id="多变一系列">多变一系列</h2>
    <h3 id="flatten">Flatten</h3>
    <p>打平，也就是把<code>[[1,2,3],[4,5]]</code>变成<code>[1,2,3,4,5]</code>这样的。可以想到把每一个每个子列表链接起来即可：</p>
    <div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(itertools.chain.from_iterable([[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>]]))</span></code></pre></div>
    <p>然而，如果输入是多层嵌套的就会失败，假如输入<code>[[1,2,3],[4,5,[6,7]]]</code>，结果是<code>[1, 2, 3, 4, 5, [6, 7]]</code>。这种时候需要使用<code>collapse</code>。</p>
    <h3 id="collapse">Collapse</h3>
    <p>用法不多说了，很简单。把一个多层嵌套的列表“打平”是常见的操作，一个常见的思路是使用递归：</p>
    <div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flat(raw, result<span class="op">=</span>[]):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> raw:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(i) <span class="op">==</span> <span class="bu">list</span>:</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>            flat(i, result)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>            result.append(i)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
    <p>如果把它改写成生成器的写法就变成了：</p>
    <div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flat(raw, result<span class="op">=</span>[]):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> raw:</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">type</span>(i) <span class="op">==</span> <span class="bu">list</span>:</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="cf">from</span> flat(i, result)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> i</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> <span class="cf">from</span> result</span></code></pre></div>
    <p>把for循环写到里面去，就变成：</p>
    <div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> flat(raw, result<span class="op">=</span>[]):</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(raw) <span class="op">==</span> <span class="bu">list</span>:</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> raw:</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="cf">from</span> flat(i, result)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> raw</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span></code></pre></div>
    <p>这其实就是库的实现方式。不过它把内部循环单独实现了一下，限制了递归级数，并且加上了对bytes,str和用户定义的“不处理类型”的处理：</p>
    <div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> walk(node, level):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (((levels <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>) <span class="kw">and</span> (level <span class="op">&gt;</span> levels)) </span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">or</span> <span class="bu">isinstance</span>(node, (<span class="bu">str</span>, <span class="bu">bytes</span>)) </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">or</span> ((base_type <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>) <span class="kw">and</span> <span class="bu">isinstance</span>(node, base_type))):</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> node</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        tree <span class="op">=</span> <span class="bu">iter</span>(node)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">TypeError</span>:</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> node</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> tree:</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="cf">from</span> walk(child, level <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="cf">yield</span> <span class="cf">from</span> walk(iterable, <span class="dv">0</span>)</span></code></pre></div>
    <p>它的函数签名是<code>collapse(iterable, base_type=None, levels=None)</code>，可以指定不处理的类型和递归层级。</p>
    <h3 id="unzip">Unzip</h3>
    <p><code>unzip</code>是标准函数<code>zip</code>的逆向过程。很容易理解，就是“先取每个迭代器的第一个组成第一个结果，再取每个迭代器的第二个组成第二个结果……”，实现方式类似于这样：</p>
    <div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>raw <span class="op">=</span> [(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;b&quot;</span>, <span class="dv">2</span>), (<span class="st">&quot;c&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;d&quot;</span>, <span class="dv">4</span>)]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> []</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>iterators <span class="op">=</span> itertools.tee(raw, <span class="bu">len</span>((<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>)))   <span class="co"># 每一个原始类型元组的长度</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> index, iterator <span class="kw">in</span> <span class="bu">enumerate</span>(iterators):</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    result.append(<span class="bu">list</span>(<span class="bu">map</span>(<span class="kw">lambda</span> x: x[index], iterator)))</span></code></pre></div>
    <p>最终的结果是<code>[['a', 'b', 'c', 'd'], [1, 2, 3, 4]]</code>。库的实现是嵌套函数，并且返回的是一个<code>tuple</code>类型。但是请注意，如果输入类型不是严格匹配，参差不一的话会抛出<code>StopIteration</code>，其中的<del>间谍</del><code>spy</code>的作用是拿到第一个元素和整个迭代器的副本并不去调用__next__()：</p>
    <div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>head, iterable <span class="op">=</span> spy(<span class="bu">iter</span>(iterable))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> head:</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ()</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>head <span class="op">=</span> head[<span class="dv">0</span>]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>iterables <span class="op">=</span> tee(iterable, <span class="bu">len</span>(head))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> itemgetter(i):</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> getter(obj):</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> obj[i]</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">IndexError</span>:</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">StopIteration</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> getter</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="bu">tuple</span>(<span class="bu">map</span>(itemgetter(i), it) <span class="cf">for</span> i, it <span class="kw">in</span> <span class="bu">enumerate</span>(iterables))</span></code></pre></div>
    <h2 id="挨个操作系列">挨个操作系列</h2>
    <h3 id="map_except">Map_except</h3>
    <p>很简单的函数，如果你有一个参差不一的列表想要<code>map</code>但不希望因为里面有一堆不想要的数据类型导致抛出异常就使用它。此函数会简单的忽略出现的异常：</p>
    <div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> map_except(function, iterable, <span class="op">*</span>exceptions):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> iterable:</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> function(item)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> exceptions:</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">pass</span></span></code></pre></div>
    <p>可以接收多个exception类型作为<code>exceptions</code>的参数，除此以外的不会被捕捉。当然，可以给一个<code>Exception</code>基类捕获一切异常。其实我来设计的话我会给它加一个默认值：</p>
    <div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> map_except(function, iterable, default, <span class="op">*</span>exceptions):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> item <span class="kw">in</span> iterable:</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> function(item)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> exceptions:</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> default</span></code></pre></div>
    <h3 id="map_reduce">Map_reduce</h3>
    <p>组合拳，略复杂，看例子：</p>
    <div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;John&quot;</span>},</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;Mike&quot;</span>},</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">2</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;Jenny&quot;</span>},</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">2</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;Wang&quot;</span>},</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    {<span class="st">&quot;type&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;data&quot;</span>: <span class="st">&quot;August&quot;</span>},</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> more_itertools</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> more_itertools.map_reduce(</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    data,</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> item: <span class="bu">str</span>(item[<span class="st">&quot;type&quot;</span>]), <span class="co"># 分类函数</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> data: <span class="dv">1</span>, <span class="co"># 转换函数</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">sum</span> <span class="co"># 规约函数</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 得到 defaultdict(None, {&#39;1&#39;: 2, &#39;2&#39;: 2, &#39;3&#39;: 1})</span></span></code></pre></div>
    <h3 id="numeric_range">Numeric_range</h3>
    <p>假设你要遍历1到10，你可以使用<code>range(1, 11)</code>，自然你也希望有一种方法可以遍历日期，分数，小数，乃至一切你直觉上觉得可以按照一定间隔遍历的东西，比如 <code>range(datetime(2022,11,11),datetime(2022,11,20))</code>这样，那么<code>numeric_range</code>就是你需要的：</p>
    <div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(more_itertools.numeric_range(datetime(<span class="dv">2022</span>,<span class="dv">11</span>,<span class="dv">11</span>),datetime(<span class="dv">2022</span>,<span class="dv">11</span>,<span class="dv">20</span>)))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="co"># 将会得到：</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>[datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">13</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">14</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">15</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">16</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">17</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">18</span>, <span class="dv">0</span>, <span class="dv">0</span>),</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a> datetime.datetime(<span class="dv">2022</span>, <span class="dv">11</span>, <span class="dv">19</span>, <span class="dv">0</span>, <span class="dv">0</span>)]</span></code></pre></div>
    <p>首先，<code>numberic_range</code>是一个继承了<code>abc.Sequence</code>和<code>abc.Hashable</code>的类，这也就意味着它并不是一个<code>iterator</code>。按照文档，继承了<code>Sequence</code>就要实现一些方法：</p>
    <div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> C(Sequence):                      <span class="co"># Direct inheritance</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>): ...             <span class="co"># Extra method not required by the ABC</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, index):  ...  <span class="co"># Required abstract method</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):  ...             <span class="co"># Required abstract method</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> count(<span class="va">self</span>, value): ...         <span class="co"># Optionally override a mixin method</span></span></code></pre></div>
    <p>与<code>range</code>函数相同，它的构造函数也接收一到三个参数，即起，末和间隔。无论给出的是多少个参数，在构造函数 中会生成<code>self._start</code>,<code>self._stop</code>,<code>self._step</code>代表起，末和间隔。为了自动推导出来，在构造函数中使用了一些技巧，也就是<code>type</code>函数。比如给出参数<code>4,5</code>，那么会使用这样的方法得出 第三个参数(自动指定间隔为1)：</p>
    <div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>start,stop <span class="op">=</span> (<span class="dv">4</span>,<span class="dv">5</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> <span class="bu">type</span>(stop <span class="op">-</span> start)(<span class="dv">1</span>)</span></code></pre></div>
    <p><code>__getitem__</code>可以处理int的key或者slice的key，按照不同的类型返回不同结果。如果是简单的获取指定位置的元素，只需要<code>self._start + i * self._step</code>即可。</p>
    <p>同样的，使用<code>self._zero = type(self._step)(0)</code>就可以得到这个类型的0值。除此以外，构造函数还需要判断给出的起末是递增的还是递减的，这个判断使用<code>self._step &gt; self._zero</code>来实现。最简示例如下：</p>
    <div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> numeric_range(abc.Sequence, abc.Hashable):</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._start, <span class="va">self</span>._stop, <span class="va">self</span>._step <span class="op">=</span> args</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># datetime(2020, 2, 10), datetime(2020, 2, 15), timedelta(days=2)</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._zero <span class="op">=</span> <span class="bu">type</span>(<span class="va">self</span>._step)(<span class="dv">0</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># timedelta(0)</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._growing <span class="op">=</span> <span class="va">self</span>._step <span class="op">&gt;</span> <span class="va">self</span>._zero</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># True</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>        q, r <span class="op">=</span> <span class="bu">divmod</span>(<span class="va">self</span>._stop <span class="op">-</span> <span class="va">self</span>._start, step)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._len <span class="op">=</span> <span class="bu">int</span>(q) <span class="op">+</span> <span class="bu">int</span>(r <span class="op">!=</span> <span class="va">self</span>._zero)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 3</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__getitem__</span>(<span class="va">self</span>, key):</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._start <span class="op">+</span> i <span class="op">*</span> <span class="va">self</span>._step</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__hash__</span>(<span class="va">self</span>):</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">hash</span>((<span class="va">self</span>._start, <span class="va">self</span>._get_by_index(<span class="op">-</span><span class="dv">1</span>), <span class="va">self</span>._step))</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__len__</span>(<span class="va">self</span>):</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._len</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>start <span class="op">=</span> datetime.datetime(<span class="dv">2020</span>, <span class="dv">2</span>, <span class="dv">10</span>)</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a>stop <span class="op">=</span> datetime.datetime(<span class="dv">2020</span>, <span class="dv">2</span>, <span class="dv">15</span>)              </span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>step <span class="op">=</span> datetime.timedelta(days<span class="op">=</span><span class="dv">2</span>)   </span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> numeric_range(start, stop, step)</span></code></pre></div>
    <h2 id="过滤器系列">过滤器系列</h2>
    <h3 id="strip-系列">Strip 系列</h3>
    <p>像字符串的<code>strip</code>函数一样，对一个序列进行操作，去除末尾元素。不过接收的是一个函数类型：</p>
    <div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>iterable <span class="op">=</span> (<span class="va">None</span>, <span class="va">False</span>, <span class="va">None</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="va">None</span>, <span class="dv">3</span>, <span class="va">False</span>, <span class="va">None</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co"># [False, None, 1, 2, None, 3, False]</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(more_itertools.strip(iterable,<span class="kw">lambda</span> x:x <span class="op">==</span> <span class="va">None</span>))</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co"># [False, None, 1, 2, None, 3, False, None]</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(more_itertools.lstrip(iterable,<span class="kw">lambda</span> x:x <span class="op">==</span> <span class="va">None</span>))</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co"># [None, False, None, 1, 2, None, 3, False]</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(more_itertools.rstrip(iterable,<span class="kw">lambda</span> x:x <span class="op">==</span> <span class="va">None</span>))</span></code></pre></div>
    <p><code>lstrip</code>的实现就是一个<code>dropwhile(pred, iterable)</code>，而<code>rstrip</code>使用一个列表来处理符合条件的元素：</p>
    <div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rstrip(iterable, pred):</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    cache <span class="op">=</span> []</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> iterable:</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pred(x):</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>            cache.append(x)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> <span class="cf">from</span> cache</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>            cache.clear()</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> x</span></code></pre></div>
    <h3 id="filter_except">Filter_except</h3>
    <p>和<code>map_except</code>类似，不过是一个过滤操作：</p>
    <div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [<span class="st">&#39;1.5&#39;</span>, <span class="st">&#39;6&#39;</span>, <span class="st">&#39;not-important&#39;</span>, <span class="st">&#39;11&#39;</span>, <span class="st">&#39;1.23E-7&#39;</span>, <span class="st">&#39;remove-me&#39;</span>, <span class="st">&#39;25&#39;</span>, <span class="st">&#39;trash&#39;</span>]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">float</span>, filter_except(<span class="bu">float</span>, data, <span class="pp">TypeError</span>, <span class="pp">ValueError</span>)))</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co">#  [1.5, 6.0, 11.0, 1.23e-07, 25.0]</span></span></code></pre></div>
    <h1 id="参考">参考</h1>
    <ul>
    <li><a href="https://more-itertools.readthedocs.io/en/stable/_modules/more_itertools/more.html" title="Source code for more_itertools.more">more_itertools文档</a></li>
    <li><a href="https://martinheinz.dev/blog/52" title="Functools - The Power of Higher-Order Functions in Python">functools介绍文章</a></li>
    <li><a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" title="Itertools Recipes">itertools文档</a></li>
    </ul>

    <br />
    <!--%%REF%%-->


    <br/>
    <div data-chirpy-comment="true"></div>
  </main>



  <footer>
    <p class="signoff">
    <div class="metadata">
            <p class="date"><time datetime="2022-12-08">创建日期：2022-12-08</time></p>
            <p class="lastmodify"><time>最后编译：2023-07-14</time></p>
    </div>
    </p>
  </footer>

  </body>

</html>