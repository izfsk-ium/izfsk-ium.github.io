[{"title": "使用 systemd 进行资源分配", "content": "uuid: \"03566ccc-fb0d-4ff6-b67f-5e0a53204d4b\" title: 使用 systemd 进行资源分配 date: 2023-07-01 category: 学习    是大多数 Linux 发行版的事实规范，不管大家喜不喜欢都要用它。这篇文章希望解决的问题是“精确的管理和控制进程/应用的各项资源”。  并不只是“进程”  对于  来讲这样的细分不够，还需要有某种把若干相关的进程组织起来的抽象。 里面主要有三种单元（）类型：  - ：服务是  依据磁盘上的配置文件自己启动的东西。一般使用  操纵的就是这类“服务”。  - ：不由配置文件启动的一组进程。只能以编程方式声明和启动。比如说使用  调用出来的子进程。比如说，在  里面运行 ，那么这个进程就会出现在某个  里面。  - ： 和  密切相关，每一个  都是一个 ，每个  都可以有自己的子 。一个  里面包含若干进程和/或子 。   自己有预先定义若干 ，分别是 ，，。所有的系统服务都放在  之中，每一个登录的用户会被分配到自己所属的  下的一个子  之中， 则是给虚拟化服务使用的。  使用  可以查看机器上的  树，举例来讲：    （以上的内容有删减。）  你可以看到，对于系统服务，例如 ，是运行在  里面的，而对于用户进程，比如火狐浏览器(app-firefox-b09f12b43b3d4b4dbf4098d695489166.scope)，则是被放置在  中。其中包含所有火狐的内容进程和其他进程。其他的进程类似。实际上很多应用并不是包含一个进程，像火狐，或者 Chrome 之类的应用都可以在  里面找到对应的 。  其实  有一个桌面环境规范，定义了常在桌面环境中见到的 ，来应用程序分配不同的优先级。所有单元都应根据其用途被放入：  - ： 只包含运行用户图形会话所需的进程。 - ： 包含用户正在运行的所有普通应用程序 - ： 适用于低优先级的后台任务  所以，像 KDE 的文件索引程序  就会被放在  里面。  能控制些啥  CPU  对于 CPU 的控制，主要使用 ，。   控制的是单元在最大时应获得多少 CPU 时间，也就是严格的 CPU 资源的使用上限，接收一个百分比值，例如 ，对于多核 CPU，这个百分比可以超过 100%，有多少个核心就可以达到多少，比如对于 16 核心的 CPU，最大可以是  。   替换了原来的 ，用来设置相对使用时间（相对权重），其值是一个整数，允许的范围是 1 到 10000 。  实例：    动态改变 ：  !  !  内存  对于内存的使用控制，主要采用  和 。  两者都接收整数值作为大小（bytes），也可以输入（K，G，M，T）的单位和百分比，用于表示最多占用机器多少比例内存。其中， 是主要的控制机制，是对目标最大可用内存的“软限制”，目标可能短暂的超过内存限制但其超出部分会被旋即回收。而  是绝对硬限制，进程超出就会出发  被当即处决。实践中结合两者使用，软硬兼施。  实例：    结果是  被 OOM 杀死：  !  对于启用的 SWAP 的系统，还有一个  可以进行控制。这是一个绝对限制。  网络  使用  和  来控制目标的联网。  - 当被检查的IP地址与 IPAddressAllow 列表中的条目相匹配时，访问被授予。IPAddressAllow 列表中的条目时，允许访问。 - 否则，当检查的IP地址与 IPAddressDeny 列表中的条目相匹配时，将拒绝访问。IPAddressDeny 列表中的条目时，访问被拒绝。 - 否则，允许访问。  | 名称         | 定义     | 含义 | |||| | any |        |  所有网络地址      | | localhost  |   | 本地回环    |  例如，要禁止联网：。  除了上面提到的，cgroup 还可以控制 IO，块设备访问等等，参见：  怎么控制  !  通过   创建一个临时控制组群：    其中：  选项为单元取一个名称。如果未指定 ，则会自动生成名称。 选项使单元成为指定片段的成员。默认情况下，服务和范围作为 systemslice 的成员创建。  成功后将会提示：   适用情况：想要一次性运行一个临时的任务，直接给出限制。例如：    适用情况：运行一个临时的任务，但想要把它放在某个特定的组里便于统一管理：    通过   位于  的伪文件系统可用于手动查看和配置 cgroup。要查看某个进程所属的 cgroup，请运行  命令。  适用情况：想要手动调整某个 slice：    通过   这是最方便的方法。  还是以调节火狐为例，首先从  里面找出其组名称：    对于使用  创建的任务单元（返回  的），以及 列出的大部分内容，无论是 slice，service 还是 scope 都可以这样管理，很方便。注意：必须添加  选项，否则找不到对应的单元!  用户单元配置文件  对于想要持久化的配置，可以使用 systemd 单元配置文件。其路径一般位于 ，示例如下：  新建文件     然后运行  接下来对于想要限制内存的应用程序这样运行：    或者写 service 也可以：    接下来    其他提示  1.  的命名规则：把 - 符号当作路径分隔符。例如  应该理解成 。systemd 会把特殊字符 escape （  ）来避免出现 - 符号。  2. 不要在  管理的任意  下面创建自己的 ，即没有设置 的 。不要在根  下面创建自己的 。“如果你直接在  根目录下创建 ，那么你所做的一切都是自找麻烦。”（Seriously, if you create cgroups directly in the cgroup root, then all you do is ask for trouble.）。  3. 不要对  创建的  的任何属性进行写入。  参考  -  -  -  -  -", "url": "/articles/使用systemd进行资源分配.html"}, {"title": "给 flutter 设置代理", "content": "uuid: \"79ef49e0-db49-4547-bfbf-78b6a511e91d\" title: 给 flutter 设置代理 date: 2023-06-28 category: 备忘录   Dart 镜像站点   会读取两个环境变量作为镜像站点的地址：  -  -   在  或者  添加：    编译时 gradle 代理  当然也可以选择镜像仓库地址，但似乎很难配置正确，而  又不吃  和环境变量，但  可以配置全局的代理设置：  更改（或者创建）文件 ，并添加：    即可。  参考  -  -", "url": "/articles/给flutter设置代理.html"}, {"title": "v2ray 结合 cgproxy 全局代理方案", "content": "uuid: \"d335a295-647a-4f5e-b15b-140178c18782\" title: v2ray 结合 cgproxy 全局代理方案 date: 2023-06-25 category: 备忘录    是使用 Linux  功能实现全局代理的工具。一般在 Linux 上使用代理工具难以设置全局代理，不同的桌面环境，不同的软件行为都不一样，有的读取桌面环境的配置，有的认可环境变量，有的在软件内配置，有的根本不提供代理设置方式。一般对于终端中的程序可以使用  来强制走代理，但这个工具是基于 ，对于静态链接的程序就不行。所以需要一个统一的解决方案。  前提准备  确保 cgroup 支持  运行 ，如果出现类似    则支持。  v2ray  首先需要安装代理工具核心。可以使用发行版提供的版本，也可以使用安装脚本。 有提供一个安装脚本。执行即可。    当然，访问  需要代理......所以你可以使用手机共享网络+分享 vpn 的方式。不过似乎中国的大部分 Android 发行版都不支持(?)  这个脚本将各个文件安装在如下位置：    值得注意的是配置文件路径：  接下来启用和运行  单元即可：    配置文件  当然是你自己搞到配置文件。无论如何，你需要得到一个完整的 json 配置文件来替换 ，关于如何从订阅链接或者从各种链接转换就不展开说明了。  其中一个办法是从手机导入，在 v2rayNG 中导出配置到剪贴板再复制到文件，然后复制到电脑上。  安装 cgproxy  首先，你的 Linux 发行版不能太旧。不然都不支持 cgroup v2。  在编译安装之前需要各种工具和相关的库：  - , ,  等编译工具：对于 Debian 系列的发行版，是；对于 openSUSE，是 。 可能不在里面，再额外安装一下就行。  - , , ： 的依赖。对于 openSUSE，软件包就是前面的名字，安装即可。对于其他发行版，请查阅文档。  接下来编译安装：    如果  报错，就按照错误找缺失的包安装。如果  报错，可能是  没有安装。  接下来  安装到系统。并启用  单元：    如果一切顺利，则会提示    修改配置文件  首先确保你的  核心运行良好，请启动它并自行寻找一个方式验证。一般来讲配置的默认入站地址有 ，所以可以在火狐中设置一下代理。总之确保目前的  配置无误。   的运行机制可以理解成这样：所有程序网路请求都会被它“拦截”并转发到 ，但转发的协议不是  或者  而是 。所以你需要额外在自己的  配置文件里面加入  的透明代理监听入站。  假设原来的配置是这样：    可以看见  区域里面有两个入站设定，现在把第三个添加到  里面：    便于查错，你可以使用  等工具打开配置文件修改和添加内容。以防万一，注意备份你的配置。  这里设置的  监听端口是  端口。修改完毕后保存，然后测试：    如果没有问题：    <del>那就是没有问题</del>  接下来重启  服务：    现在开始修改  的配置文件，其位于 。  默认情况下：    就已经够用。其中  就是之前新增的  监听端口，而  是不进行代理的程序名称。 当然要排除在外，不然就是循环代理了。  保存配置文件。  启用  确认都配置好了以后， 启动服务，使用以下命令测试：    注意，先取消之前设置的代理。(清除环境变量，设置等)。如果没有任何问题，就可以稳定运行了。  其他  要查看  的日志：    要停止 :    注意：必须使用  来关闭服务，否则下一次启动可能会失效！  参考  -  -  -", "url": "/articles/v2ray-core+cgproxy全局代理方案.html"}, {"title": "使用 chntpw 修改 Windows 密码", "content": "uuid: \"17e1a6a4-4eed-4a8e-94ae-5ed078e75530\" title: 使用 chntpw 修改 Windows 密码 date: 2023-06-22 category: 备忘录   对于上了密码的 Windows 系统，虽然没办法直接登录，但只要没有全盘加密，并且 BIOS 没有上锁，就可以通过引导其他系统来清除密码。  准备   这个工具大多数常规 Linux 发行版并不会在 Live 系统里面预置。据说 Kail 的 Live CD 里面有自带这个工具，但我从来没用过 Kail。我选择的是专门用来进行系统维护的 。可以在下载其 iso 文件。刻录完成后即可使用。  实际测试表明， 可以更改 Windows 10 家庭普通版的密码。  进入系统  首先需要进 BIOS 修改启动顺序，顺便把安全启动关掉。然后进入系统：  !  挂载硬盘  需要找到的是装有 Windows 根目录(?)的那个硬盘分区，一般的电脑就是最大的那一个。当然，实在拿不准的话就把几个硬盘都挂载上再说。  !  对于 Windows 7 和 Windows 8.1，大多数情况下就直接挂载成功了，最多自动做一个 fixing 也就继续挂载。但是对于 Windows 10 和 Windows 11，默认情况下系统会保留休眠文件（hiberfile.sys）以供下次快速启动。当然，可以在 Windows 里面用 powercfg 关掉，但咱们这么搞不就是因为不知道密码么（  解决方案，使用  移除休眠文件即可，但首先需要把自动只读挂载的分区 umount 掉。  接下来：    确保是读写挂载：  !  找到并更改 SAM 文件  Windows 的用户数据库位于 :  !  接下来使用  列出所有用户的资料：  !  接下来选取用户进入交互编辑模式。使用 RID 而用用户名，因为用户名可能包含空格甚至非 ASCII 字符，tty 下根本打不出来。在键入 RID 注意格式，例如  要键入为 ：  !  要清除密码，键入  然后回车即可。操作完毕以后，输入  回车，会提示是否保存，键入  回车确认就完成了。  接下来回到根目录  即可。再次进入 Windows ，密码就消失了。  建议和提示  1.  不能从哈希还原出密码，除非是你自己的电脑，直接清除用户密码就是告诉机主自己过来溜门撬锁过。因此要记得备份原来的 SAM 文件以供还原。  2. 关于  账户：现代 Windows 中 Administrator 账户并不是没有，只是默认被禁用了，这一点  可以看得到。除了选择清除已有用户的密码，还可以选择激活这个默认没有密码的账户。在使用 Administrator 进入 Windows 并操作完成后，可以  再禁用它。  3. 无论如何，你总会留下蛛丝马迹，比如审核日志，比如消失的休眠文件，害人之心不可有。  参考  -  -  -", "url": "/articles/使用chntpw修改Windows密码.html"}, {"title": "Getx速查表", "content": "uuid: \"7f58b9f5-d420-4722-8d41-6191a9453397\" title: Getx速查表 date: 2023-06-01 category: 备忘   安装  在  中添加：    注意不用添加版本号。然后在文件中可以使用  引入。  路由  所有的路由都不需要传入 。  简单路由  - 导航到新的页面： - 返回到之前的页面，也包括关闭 ， 和  等元素： - 导航到新的页面，不能返回： - 导航到新的页面，把之前的东西统统关掉：  路由也可以传输数据，像这样获取页面数据：    对应的页面这样返回数据：    命名路由  首先需要定义路由：    使用方法还是类似无名路由：    可以看到给路由加参数也是可以的，在对应的页面的控制器或类中使用  就可以获取到。除此以外还可以使用类似 Web URL 的方法传递 :。获取它们是这样：    还可以给路由加上 :    Snakebar 和 Dialog    无需 。  BottomSheet  BottomSheet 就是在页面底部从下往上弹出的那个菜单一样的东西：    状态管理  有了 ，再也不需要使用  了。  常用模式  一个通常的模式是这样的：一个页面对应一个控制器()，这个控制器扩展了 。在一个 Controller 类中，一个  会自动更新订阅了它的组建，其他不是  的数据必须在修改它们的方法中使用  才行。  对于响应式的变量，有特殊的类型来处理：    当然，要获取它们的实际值就需要  了。  如何使用：    注意事项：如果要在控制器里面初始化什么东西（网络连接，文件，数据库），不要使用类初始化函数，而是使用 。同样的，使用  而不是 。    Workers  当特定事件在某个值上发生时的 callback：    StateMixin    依赖管理  何时初始化    细节    最常见的插入依赖关系的方式： 和     文档有中文版本。（）  Bindings    啥时候去 Put 你的 Controller 总是个问题，Bindings 就是解决这个问题的，它将路由、状态管理器和依赖管理器完全集成。首先创建 binding 类：    然后在路由中使用它们：    参考  -  -  -", "url": "/articles/Getx速查表.html"}, {"title": "基础光线追踪", "content": "uuid: \"3d0d8a7b-1966-435e-98dd-b4c59ffd581f\" title: 基础光线追踪 date: 2023-04-25 category: 学习   光线追踪  如图所示  !  摄像机位于坐标系原点，设为$O$，方框则为 Viewport．设$V_w=V_h=d=1$单位长度时，视角$FOV=53^o$.要从$O$进行光线追踪，就是从原点发出一条射线(实际的光线是从物体反射到摄影机，而不是从摄影机发射出去)，穿过 Viewport 直达物体. 光线追踪的算法如下：    1. 放置摄像机(camera)和(viewport) 2. 对于画布(canvas)上的每一个点:     - 找出 Viewport 上对应的那一个点     - 找出对应的颜色     - 在画布上画出那个点  光路表示  给定原点$O$，$\\vec {VO}$ 为光线的方向，设为$\\vec D$，那么该光线上的任意一点$P$可以这样表示：$P=O+t\\vec D$  球的表示  为了简单起见，设空间中的物体为球，即：与一固定点$C$距离为$r$的所有点$P$的集合，即向量$\\vec {PC}$的长度为$r$.  $$ |\\vec {PC}|=r $$  又  $$ \\vec {PC} \\cdot \\vec {PC} = r^2  $$  所以得到方程组，也就是光线和球的交点：  $$ \\begin{cases} \\vec {PC} \\cdot \\vec {PC} = r^2 \\\\ P = O+t \\vec D \\end{cases} $$  其中：  - $O$为原点 - $r$为半径 - $C$为圆心 - $\\vec D=\\vec {VO}$即光线的方向  所以要求的就是$t$.  方程组  把二式代入一式：  $$ \\langle O + t\\vec{D} - C, O + t\\vec{D} - C \\rangle = r^2 =  $$ $$ (\\vec{CO}+t\\cdot\\vec{D})\\cdot \\vec{CO}+(\\vec{CO}+t\\cdot\\vec{D})\\cdot t\\cdot \\vec{D} =  $$ $$ \\vec{CO}^2+2\\cdot\\cdot t \\cdot \\vec{D}+t \\cdot \\vec{D}^2 = r^2 $$  也就是二次方程：  $$ t^2 \\cdot \\vec{D}^2 + 2 \\cdot t \\cdot (\\vec{CO} \\cdot \\vec{D}) + \\vec{CO}^2 - r^2 = 0 $$  按照$\\Delta$分类讨论：  $$ \\Delta = [2(\\vec{CO} \\cdot \\vec{D})]^2 - 4t^2(\\vec{CO}^2-r^2) $$  !  参考：  -", "url": "/articles/基础光线追踪.html"}, {"title": "刚好够用的线性代数基础", "content": "uuid: \"45479e53-d727-48f5-8946-657556b4110c\" title: 刚好够用的线性代数基础 date: 2023-04-21 category: 学习   向量、向量运算和矩阵运算  向量()  表示两点之间的不同，可以看作是指示一个点如何向另外一个点移动。区分两个向量的要素：方向()和长度()。  向量的长度()  向量的长度这样表示：$|\\vec V|$，可以通过坐标计算：  $$ |\\vec V| = \\sqrt{V_x^2+V_y^2+V_z^2} $$  就是说，把这个向量挪到原点那里，然后计算“那条线段”的长度。  从点到向量  向量指两个点怎么移动，假如说有两个点$P$和$Q$，要指示$P$移动到$Q$，就是：  $$ P+\\vec V = Q , \\vec V = Q-P $$  计算的方法就是点的坐标运算。  向量的加法  $$  \\vec V+\\vec W=(V_x,V_y,V_z)+(W_x,W_y,W_z)=(V_x+W_x,V_y+W_y,V_z+W_z) $$  放缩()  通过乘一个数，把向量变长变短或者改变方向：$k \\cdot \\vec V = k \\cdot (V_x,V_y,V_z) = (k \\cdot V_x,k \\cdot V_y,k \\cdot V_z)$  除法就是乘它的倒数。把一个向量除它的长度得到单位向量。  $$ \\vec {V_{normalize}} = \\frac{\\vec V}{|\\vec V|}  $$  点乘()  表示方法：$\\vec V \\cdot \\vec W$ 或者 $\\langle \\vec V,\\vec W\\rangle$  计算方法：  $$ \\vec V \\cdot \\vec W = V_x \\cdot W_x + V_y \\cdot W_y + V_z \\cdot W_z  $$  或者  $$ \\vec V \\cdot \\vec W = |\\vec V|\\cdot|\\vec W|\\cdot\\cos(\\alpha)  $$  其中 $\\alpha$ 是两个向量的夹角  其他：  $$ \\alpha = \\cos^{-1}(\\frac{\\vec V \\cdot \\vec W}{|\\vec V|\\cdot|\\vec W|}) $$  $$ |\\vec V| = \\sqrt{\\vec V \\cdot \\vec V} $$  叉积（）  向量的 Cross Product（叉积）是一种二元运算，其结果是一个向量。写作 $\\vec V \\times \\vec W$，三维空间中的两个向量的叉积大小等于两个向量所在平行四边形的面积。  如果 $\\vec R = \\vec V \\times \\vec W$，那么：  $$ R_x = V_y \\cdot W_z - V_z \\cdot W_y $$ $$ R_y = V_z \\cdot W_x - V_x \\cdot W_z $$ $$ R_z = V_x \\cdot W_y - V_y \\cdot W_x $$  注意：$\\vec V \\times \\vec W = -(\\vec W \\times \\vec V)$   矩阵（）  矩阵就是一个方框里面的一堆数字，嗯。  行列式()：  行列式是一个矩阵的一个标量值，用于描述线性变换对面积或体积的缩放因子。就是说，对于一个线性变换，行列式得到的是这个变换对面积或者体积产生的变化。<del>为什么翻译成“行列式”</del>。  计算方法：  $$ dec(     \\begin{bmatrix}     a & b \\\\     c & d      \\end{bmatrix} ) =  ad -  bc $$  例如：  $$ dec( \\begin{bmatrix} 0.0 & 2.0 \\\\ -1.5 & 1.0 \\end{bmatrix} ) = 3.0 $$  表示这个线性变换把原来平面里面所以的图形的面积缩放两三倍。如果行列式的结果得到$0$，就意味着这个线性变换进行了降维。  考虑这个行列式：  $$ dec(     \\begin{bmatrix}     2 & 1 \\\\     -1 & -3     \\end{bmatrix} ) = -5.0 $$    出现了一个负数，这意味着这个线性变换把整个空间翻了个面。  加法：  $$ \\begin{bmatrix} a & b & c \\\\ d & e & f \\\\ g & h & i \\end{bmatrix} + \\begin{bmatrix} j & k & l \\\\ m & n & o \\\\ p & q & r \\end{bmatrix} = \\begin{bmatrix} a+j & b+k & c+l \\\\ d+m & e+n & f+o \\\\ g+p & h+q & i+r \\end{bmatrix} $$  点乘：  $$ n \\cdot \\begin{bmatrix} a & b & c \\\\ d & e & f \\\\ g & h & i \\end{bmatrix} = \\begin{bmatrix} n \\cdot a & n \\cdot b & n \\cdot c \\\\ n \\cdot d & n \\cdot e & n \\cdot f \\\\ n \\cdot g & n \\cdot h & n \\cdot i \\end{bmatrix} $$  矩阵向量乘法：  “线性变换”是处理向量的函数，空间会因为各种变换而扭曲变形，如果一个变换是线性变换，那么：  - 直线依旧是直线 - 原点保持不动  用数学方法描述这种变换，例如，“把空间网格旋转九十度”，只需要描述和记录两个基向量即可，其他的向量都可以通过（变化后的基向量）计算出来，于是，一个二维空间的线性变换可以用四个数字确定：变化后的两个基向量的坐标。把这四个数字放在一起，变成 $2 \\times 2$ 矩阵：  $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} $$  其中，$a$ 和 $c$ 是第一个基向量的坐标，$b$ 和 $d$ 是第二个基向量的坐标。  那么想要知道这个矩阵所描述的线性变换对给定的向量的作用效果，就是把它和这个矩阵相乘：  $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\end{bmatrix} = x \\cdot \\begin{bmatrix} a \\\\ c \\end{bmatrix} + y \\cdot \\begin{bmatrix} b \\\\ d \\end{bmatrix} = \\begin{bmatrix} ax + by \\\\ cx + dy \\end{bmatrix} $$  矩阵乘矩阵  向量乘矩阵，表示的是对该向量应用矩阵所描述的线性变化，那么，如果要对这个向量做多次变换：  先进行一个变换：  $$ \\begin{bmatrix} a_1 & b_1 \\\\ c_1 & d_1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} $$  再进行第二个变换：  $$ \\begin{bmatrix} a_2 & b_2 \\\\ c_2 & d_2 \\end{bmatrix} ( \\begin{bmatrix} a_1 & b_1 \\\\ c_1 & d_1 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} ) $$  而这个“多次变换”的过程，可以复合起来，看作一个操作，那么就可以写成：  $$ \\begin{bmatrix} a_3 & b_3 \\\\ c_3 & d_3 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} $$  于是，把两个式子的 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$删掉，就得到了矩阵乘法，它的含义就是：复合两个线性变换，计算方法：  $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \\begin{bmatrix} e & f \\\\ g & h     \\end{bmatrix} $$  首先计算应用左边变换后的第一个基向量：  $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}\\cdot \\begin{bmatrix} e \\\\ g \\end{bmatrix} $$  得到的就是最终结果的第一个基向量。同样的，对右边的基向量进行操作，得到第二个基向量：  $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}\\cdot \\begin{bmatrix} f \\\\ h \\end{bmatrix} $$  所以  $$ \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \\begin{bmatrix} e & f \\\\ g & h     \\end{bmatrix} = \\begin{bmatrix} ae+bg & af+bh \\\\ ce+dg & cf+dh \\end{bmatrix} $$  注意：$M_1 M_2\\ne M_2 M_1$  矩阵和线性方程组  矩阵可以用来表示线性方程组，把所有的系数写起来，叫做系数矩阵，把后面的常数项也写进来，叫做增广矩阵。 $$ \\begin{cases} ax+by=e \\\\ cx+dy=f \\end{cases} $$  可以写成：  $$ \\begin{bmatrix} a & b & e \\\\ c & d & f \\end{bmatrix} $$  而如果把未知数提出来，写成向量的形式，那么：  $$ \\begin{bmatrix} a & b \\\\ c & d  \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} e \\\\ f \\end{bmatrix} $$  可以写成$A\\vec x=\\vec v$就意味着：对向量$\\vec {xy}$所在的空间进行一个变换，使得变换后的该向量落在新的$\\vec {ef}$重合。  判断这样的解是否存在可以用到行列式，如果$det(x)=0$就意味这个空间被“压缩到更低的维度”。  矩阵的逆  矩阵的逆写作$A^{-1}$，意思是进行这个矩阵所描述的线性变换的逆向变换，于是$A^{-1}A$就是“什么也不做”。  秩()  秩代表变换后空间的维数，也就是列空间的维数。对于一个向量$\\vec V$，应用变换$A$所得到的所有可能的向量的集合称为$A$的列空间。秩与列数相等，称为满秩。  对于一个变换，总是有一些向量在变换过后位于原点，例如$\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$总是变化后位于原点，无论是什么变换。而对于非满秩的变换，总有一个直线或者一个面或者其他什么东西被“压缩”到原点位置，这些倒霉向量的集合成为核或者零空间", "url": "/articles/刚好够用的线性代数基础.html"}, {"title": "关于光线追踪,颜色和反射", "content": "uuid: \"5ef70152-7905-48bc-b22e-51a82d1956d6\" title: 关于光线追踪,颜色和反射 date: 2023-04-20 category: 学习  关于颜色  人类的眼睛只能看见特定波长的光（），低于的部分叫做红外线，高出的叫做紫外线。所有的颜色都可以看成是几种原色（）的线性组合。  减色模型（）  物体反射光线，白色的光线照射到某个物体上，该物体在反射的同时吸收了一部分波长的光（这些颜色被“减去”）了。例如，白纸上的黄色图案只允许黄色通过，蓝色图案只允许蓝色通过，不断叠加，最后不允许任何颜色通过，那就是黑色。实际操作中的减色模型一般使用  模型，四中基本色是 Cyan, Magenta, Yellow 和 Black。  增色模型（）  有的物体不发光，有的物体发光。对于发光的物体，使用增色模型，例如电脑屏幕，放大以后就能看见小小的三种颜色的发光元件密集排列。在这种情况下，几种原色的混合不是形成黑色，而是形成白色。  颜色的相关计算  设一个颜色表示为：  $$ (R,G,B) $$  那么  $$ k\\cdot(R,G,B) = (kR,kG,kB) $$ $$ (R_1,G_1,B_1)+(R_2,G_2,B_2)=(R_1+R_2,G_1+G_2,B_1+B_2) $$  关于光源  点状光源（或）  点状光源位于$3D$空间中一点，向各个方向放射出光线，类似于白炽灯。对于空间中的任何一点，点状光源对其的光照向量都是不同的。  有向光源（）  有向光源没有位置，具有固定的方向，在地球上太阳就相当于一个有向光源。对于环境中的每一点，有向光源对其的光照向量的都是一样的。  环境光源（）  如果没有环境光源，那么没有被光源直接照射到的地方将会是完全的黑色，这并不河里，物体本身或多或少都会反射光，这些复杂的反射光构成了环境光源。它只有强度。对于一个场景来讲，只有一个环境光源，可以有任意个点状或有向光源。  关于反射  法向（）  黑话，全称是“法向量”。垂直于面上一点$P$之单位向量谓之法向量，用于该面方向 之表征。想象一下里面拖动面的那个垂直箭头。  漫反射（）  漫反射的物体将光线均等的反射到所有方向，无论在什么方向看这个物体都是一样的。可以看成一个凹凸不平的平面，坑坑洼洼，所以光线被反射到各个不同的方向。例如纸张或者一般墙壁。漫反射所反射的光线的数量取决于光照的角度。角度越大，同样能量的光照就要分布到更大面积的物体上，那么这个物体受到的光照能量就越小。  给漫反射建模，就是要找出给定光照的前提下，这个表面上的点到底反射出了啥。  !  - 光线$L$具有强度$I$，方向$\\vec L$ - 平面的法向量$N$  假设光线的“宽度”($I$)就是它的强度，那么$A$的长度就是平面得到的能量。可以看出随着$\\beta$越来越大，$A$越来越趋近于$I$，那么表面也就越亮，反之，$\\lim_{A \\to \\infty} {I \\over A} = 0$，那么也就是一片黑暗了。  毫无疑问，表面光照与法线和光照夹角有关，表示为一个函数：  $$ {I \\over A}  = {{\\vec{N} \\cdot \\vec{L}} \\over {|\\vec{N}||\\vec{L}|}} $$  漫反射公式  The Diffuse Reflection Equation：  $$ I_P =  I_A  +  \\sum_{i = 1}^{n} I_i      {{\\vec{N} \\cdot \\vec{L_i}}      \\over      {|\\vec{N}||\\vec{L_i}|}} $$  其中：  - $I_P:$具有法向$\\vec N$的点$P$所获得的全部光照 - $I_A:$环境光照的强度 - ${{\\vec{N} \\cdot \\vec{L}} \\over {|\\vec{N}||\\vec{L}|}}:{I \\over A}$ - $I_i \\cdot {{\\vec{N} \\cdot \\vec{L}} \\over {|\\vec{N}||\\vec{L}|}}:$计算光照强度  镜面反射（）  与漫反射不同，镜面反射就是让光线怎么进来怎么出去。很好理解。  !  $N$是法向，光线从$L$进去，从$R$出来，我们位于$V$的摄影机看到的光线就是要计算的目标。当$\\alpha=0$，你就被亮瞎啦。  镜面反射公式  $$ \\vec{R} = 2\\vec{N} \\langle \\vec{N}, \\vec{L} \\rangle - \\vec{L} $$ $$ I_S = I_L \\left( {{\\langle \\vec{R}, \\vec{V} \\rangle} \\over {|\\vec{R}||\\vec{V}|}} \\right)^s $$  那么  $$ I_P = I_A + \\sum_{i = 1}^{n} I_i \\cdot \\left[ {{{\\langle \\vec{N}, \\vec{L_i} \\rangle} \\over {|\\vec{N}||\\vec{L_i}|}} + \\left( {{\\langle \\vec{R_i}, \\vec{V} \\rangle} \\over {|\\vec{R_i}||\\vec{V}|}} \\right)^s} \\right] $$  参考：  -", "url": "/articles/关于颜色和反射.html"}, {"title": "给Nautilus添加自定义菜单项", "content": "uuid: \"de5bb46d-a069-4de8-b61b-18cfe5e38fc7\" title: 给Nautilus添加自定义菜单项 date: 2023-04-13 category: 杂项   > “GNOME’s […] excuse for not doing something is not it’s too complicated to do , but it would confuse users . The whole we know best thing is a disease.” — Linus Torvalds  首先，我必须要狠狠的吐槽 Nautilus 的设计 —— 事实上是整个 Gnome 的设计哲学，如果这样扭曲的思维也能叫做一种“哲学”的话。默认的Gnome，说得好听叫简洁，说得难听叫简陋，做减法做过头。我知道 Gnome 的设计借鉴和吸收了 MacOS 的简洁，但在实际上，他们似乎搞错了“简洁”和“简陋”的区别。以至于搞出了一个看上去很简洁，但用起来大量缺失基础功能的精品毛坯房。在 Gnome 中，回字不会有四种写法——它干脆不提供这个字。已经是 2023 年了，连 Windows 的资源管理器都添加了“在这里打开终端”的上下文菜单，Nautilus 的菜单项目倒是越来越少了。  当然，Nautilus 天才的设计者对极致简洁的不懈追求并没有止步于不添加新的功能，他们也没有忘记砍掉原本好用的老功能。曾经有一个叫做  的（官方）项目，用户可以给 Nautilus 添加自定义的菜单内容，这样如同火箭科学一样复杂难懂的功能想必是根本不会有人用的，于是它就被砍掉了。  幸运的是，为我这样庸俗的，不懂得面向未来的低端用户弥补了这个缺陷，以下是安装和配置过程：  首先，安装对应的依赖，对于 openSUSE, 需要安装的包是：    其他的无关紧要，当然为了能够正确弹窗和访问剪贴板，最好再安装一下  和 。  接下来克隆 repo ： ，安装：。然后注销并重新登陆。接着在全部应用里面寻找 ：  !  然后就能够运行了。这是一个网页程序（），将会在浏览器里面打开：  !  编辑基本上是有手就行，但是注意：在这里编辑并保存以后是有可能无效的，也就是说根本没有真的保存。如果刷新以后总是显示原始配置，那么恭喜，你不得不和我一样自己编配置文件。配置文件的位置是：，内容是 JSON 文件。附上我调试出来的配置一份：   当然保存以后可能还是没有生效， 试试看，再不行就注销重新登陆一下。  这一番折腾下来，说句老实话我的耐性基本上被消磨干净了。在其他类似软件里触手可及的功能却要配置老半天，而且说不定就在下次某个版本的“砍功能”环节中失效。  我觉得 Gnome 的哲学是这样的：  - 小而美（小的程序比对的程序更称心如意） - 简洁干净（达到最 要求就足够了） - 标准（标准可以有很多个，而且随时能更改）  所以，我的最终决定还是：    参考：  -  -  -", "url": "/articles/给Nautilus添加自定义菜单项.html"}, {"title": "当用户爬行的时候", "content": "uuid: \"dc6740ad-5546-451a-a74a-c3721cdd76ca\" title: 当用户爬行的时候 date: 2023-04-06 category: 杂感   我曾经有幸看到过用户和界面交互的场景。那真是让人绝望：很显然，他们不明白登录和不登陆有什么区别，当遇到问题时，他们在很明显不是交互元素的地方徒劳而倔强的反复的点击，有的用户还算有那么一点使用浏览器的经验，至少知道「刷新」这一功能，于是接连不断绝望的刷新着网页，期待着某一次刷新过后能够魔法般的获得登录状态......  看到这种情况，开发人员的恨不得拧着用户的耳朵教会他们，然而目前的技术并不能让人手从显示屏中伸出来，而连登录按钮都看不到的人，自然也不能指望他去阅读有小拇指那么厚的用户文档。他们倔强，会使用各种百度出来的那些奇怪、过时、错误、莫名其妙的技巧反复尝试，但他们又很浮躁，既不愿意了解登录的作用，也不愿意花费哪怕是5分钟时间看一下文档或者来请教一下用户支持，在这种情况下，如果开发者有幸能够发觉这一情况，解决的方案自然只能是给登录按钮加粗，加大，加边框，加背景颜色，乃至到让它漂浮起来像抹了油的台球似的满屏幕弹来弹去────没错，就是那种经常在政府网页上看见的 js 漂浮卡片：它们真的很难看，但真的很管用。  任何开发人员都不会愿意看到自己的用户是这样的情况，你修了一条路，自然希望人家老老实实是走，或许还能跑，但绝对不希望人家蚰蜒一样曲折的爬行。然而现实情况却总是让人觉得自己不是在修路而是在养蛊。有一个「二八定律」,说法是 80% 用户只会去使用 20% 功能，虽然我觉得从软件功能开发上看这句话并不一定合理，还容易成为偷懒的滥觞，但如果按照它的说法，把用户分为百分之二十的「高级用户」和百分之八十的「一般用户」的话，那么对于软件产品的反馈，百分之八十来自于那些「高级用户」，而那些占据大头的普通用户则是实打实的「沉默的大多数」。这些人计算机操作经验普遍的不足，乃至看着他们操作会让我们这种自诩「专家」的人莫名的生起气来。  对于这些用户，我的项目经历告诉我：  1. 他们可能会以一种开发者意想不到的方法使用应用程序。 2. 他们永远不会报告和反馈遇到的困难和bug。 3. 他们最终还是会成功。  这类用户占据了很大一部分，他们认为「文件管理」就是「qq浏览器」，分不清「内存」和「存储」，问他使用什么系统会很认真的回答你手机的品牌，他们不关心你的 CDN 有没有使用 http3 和 brotli 压缩，他们只是希望这个「东西」能够好好干活，而他们的期望也很具体，某个具体的窗口，一行特定的提示字符串就是成功的符号。  但开发者看不见他们。或者说，不愿意看到他们。人总是希望看到自己希望看到的东西，而有意或无意的忽略不合口味的东西。或许程序员多少都有些孤芳自赏，作为开发者，理想的用户是这样的：他有大把的时间研究手册，受到相当程度的计算机教育，汇报 issue 时条理清晰内容简洁，闲时还能和你唠唠技术上的实现细节的阳春白雪（自然，最后还是你占上风）......但即使是在 20% 的「高级用户」中，这样的人也是屈指可数的。而对于一般用户和缺乏计算机能力的用户，却只能受到白眼乃至逐客令 ──── 这一点在某些精英化的开源/自由软件中尤其突出，反而是不够自由的商业软件给了这些低级用户不受（技术上的）歧视的自由。于是，一方面用户沉默不语（即使有什么想说的也入不了开发者的法眼），一方面是开发者日益闭门造车孤芳自赏唯我独尊众人皆醉我独醒，这当然对于软件本身是不利的。如果看见用户在爬行，就应该扶他们起来，而不是抱着「不会走路就给爷爬」的心态和态度把他们一概归为「低端用户」，冷冰冰的一句「不会用就别用」是不可能吸引到更多的用户，以及维持一个健康的社区的。  而让用户都去主动适应开发者的「哲学」，要用户来学习他们的软件，就像是某些老板命令程序员实现「能够根据手机壳的颜色切换应用主题」一样娘希匹了。", "url": "/articles/当用户爬行的时候.html"}, {"title": "Adalang初探", "content": "uuid: \"8f47beda-8cb7-4835-a463-a60e6ac2dcd5\" title: Adalang初探 date: 2023-03-24 category: 学习   学习 Ada 的原因无非是两个：一是好奇这个从来没有接触过的语言，二是想要尝试一个不同「风格」的语言。  首先是要安装开发环境。Ada 语言是 GCC 编译器集合里面官方支持的。但光有编译器还不行，还需要工具链条，以及 IDE。具体的来讲就是：  - 安装 GNAT：； - 安装 GPRBuild，Ada 的项目管理工具，需要在 OBS 里面下载：  创建和编译运行的简单示例：  1. 创建 gpr 项目文件：        2. 创建源文件：        3. 编译运行：        可以看到相比于 C 系的大括号语言和 Python 系的游标卡尺语言，Ada 在语法上有明显的不同，举个例子：    首先，Ada 是严格区分「过程」和「函数」的。函数必须返回一个值，而过程不一定需要。我印象里面似乎只有 Pascal 这样干。Functions 和 Procedures 都是 。函数作为表达式的组成部分被调用，并返回一个值作为表达式的一部分，而过程就是「一组语句」。定义一个过程如下：    调用过程则是：。比较奇特的是，如果过程没有参数，那么调用也不需要括号。所以直接调用  是换行，加一个括号调用  则是 10 个空行：    这里还有几个点：首先是过程的参数有  和  两种， 关键字表示参数在过程中是只读的，这意味着过程可以访问参数的值但不能修改它。 关键字表示参数在过程中是只写的，这意味着过程可以修改参数的值但不能读取其原始值；其次获取一个对象的属性是使用  符号而不是其他语言的  表示方法，所以获取字符串的长度就变成了 ；再者，给一个变量赋值是使用  符号而非  符号、指明类型（Ada 是强类型语言，必须指明类型）是使用 ，这一点倒是和 Typescript 一致，最后，注释使用  符号。所以可以很方便的框一个大框出来（  另外，Ada 中的定义变量必须在 begin 之前。  调用：    相比之下，定义一个函数是这样的，必须要指明返回类型。调用方法和过程类似。    接下来是喜闻乐见的基本 statements 环节，举例说明：  If    注意，判断相等是  而不是 ，判断不相等是  而非 。除此以外，判断是否在一个范围可以这样：。  case (switch)    以及范围测试：    loop  首先 Ada 中的  大致可以替换成 ，所以：    就是    for    异常处理  Ada 内置了完整的异常处理机制：    Ada 中有以下几种异常：  - ：当某个值不符合类型限制时抛出 - ：当程序出现逻辑错误时抛出 - ：当程序无法分配足够的内存时抛出 - ：当任务相关的错误发生时抛出 - ：当数字计算出现错误时抛出 - ：当某些检查失败时抛出 - ：当系统错误发生时抛出 - ：当程序使用不正确时抛出 - ：当程序中的断言失败时抛出  MultiTasking  说起  现在第一个想到的就是 ，但 Adalang 这个比我的年龄还大的语言也可以做到：而且一点也不勉强：    程序的输出是    并且是并行的。   也可以轻松实现：    结果：    编译结果   总而言之，Ada 是一个超越时代的语言，它有类似 Golang 甚至 Rust 的一些特性，而且语法也很优雅，但时代局限了它。  参考  1.  2.  3.", "url": "/articles/Adalang初探.html"}, {"title": "给Apache2安装ModSecurity", "content": "uuid: \"fa8435d4-54a4-4d3a-bb65-d26f913e009e\" title: 给Apache2安装ModSecurity date: 2023-03-10 category: 技术   我想要禁止服务器发送 Server: Apache 的 Header，但是不能通过直接配置的方法实现，需要使用第三方模块来实现。也就是这个 ModSecurity。除了这个功能以外 ModSecurity 就像它的名字那样包含了大量的的安全加强功能。  首先你需要安装一系列前置:编译器套件不用多说，在 SUSE 上还需要额外安装 gcc-c++ 。除此以外还有其他的前置需要安装， 即可。  接下来编译安装 ModSecurity 主体：    接下来手动拷贝一下模块文件：    这样主体安装完成。对于 Apache 服务器还需要安装对应的连接器：    如果提示找不到  说明需要手动寻找一下安装位置。一般就是在  之中：    接下来开启模块：    注意添加配置文件。日志里面可以看到这个：    -  -", "url": "/articles/给Apache2安装ModSecurity.html"}, {"title": "编译安装ApacheServer", "content": "uuid: \"1a6ce92c-d5be-4fdb-a324-fa03d0dd6e93\" title: 编译安装ApacheServer date: 2023-03-04 category: 备忘录   早上收到 linuxOne 的邮件：  !  一开始受宠若惊，毕竟这样就某个软件的漏洞专门发邮提醒的服务商不多见，仔细一看人家是 kindly ask you to correct all the ones listed below within 5 days...... 好吧，那看来我不在 5 天内修复那我就要寄，白嫖党可没什么好硬气的，人家都警告的 Your access will be revoked for any non-compliance.  本来以为是  一波，但是软件源里面的 apache 版本只到 2.4.52，只能自己编译安装了。  整个依赖链条是这样的：    所以需要单独编译安装它们。  一图以蔽之：  !  0. 首先：卸载原来的 apache2，使用  因为自己编译安装的 apache 不使用 /etc 里面的配置文件。  1. 安装编译器集合        2. 安装             注意它需要  但是软件源里面安装的  需要手动软链接一下：            接下来再        3. 安装       替换为最新的版本！        4. 安装       寻找最新的版本：        - 配置文件位置： - 服务器控制：  所以启动服务器：  再次编译升级  在已安装服务器的构建目录中或旧安装的源代码树的根目录中找到文件 。然后，将  文件复制到新版本的源代码树中，对其进行编辑以进行任何所需的更改，然后编译即可。   所以 IBM 为什么知道 Apache 的版本   一下，看见两个程序  ， 之看见不少 ， 之类的字符串，看来就是它没错了。  当然我还是不敢去掉它们，毕竟我也不知道这算不算 （  后续  服务器被收回了，悲......  参考  -  -", "url": "/articles/编译安装ApacheServer.html"}, {"title": "使用fetch下载时获取进度信息", "content": "uuid: \"3f650bd0-bdbb-4ac4-a2a6-5c62da3749dd\" title: 使用fetch下载时获取进度信息 date: 2023-03-02 category: 学习   一般当要在前端动态的使用  下载某物的时候，常规的模式是这样的：    这样做有一个坏处：不能显示进度。返回的 blob 必须要等到下载全部完毕以后，才能有反映。对于比较大的文件，用户的观感就是页面「卡住了」，然后不停的重复点击。更好的做法是把接收的流资源分成一个个小的分块，然后按位处理它。  流 API  在  第一步返回的  类型中包含了请求的状态，大小长度， 等等的信息，而文件的大小就可以使用  来获得。为了获得每一块的状态则需要返回一个 。  具体的来讲第二步返回的内容是这样：    这一步返回的东西依旧是一个 ，所以下一步还是需要用  来获得最终的数据。    上传进度（使用 XHR ）  很遗憾  不支持给上传请求提供进度信息，所以不得不使用更加古典的  请求：    注意是  而不是   参考  - 可显示进度的  示例： - ReadableStream )", "url": "/articles/使用fetch下载时获取进度信息.html"}, {"title": "博客迁移从域名到部署", "content": "uuid: \"3dcffc06-560d-4ab2-9c64-62cf2b24682a\" title: 博客迁移从域名到部署 date: 2023-02-26 category: 杂项   本站进行了一次迁徙，其实也不能说是完全的「迁徙」，但不管怎么样，现在可以使用自己的域名，而不是托管使用 github.io 的子域名了。除此以外，部署方式也作了修改，不再使用中国境内访问慢吞吞的 Github Pages 而采用 render.com 提供的部署服务，同时也套上了 Cloudflare。总之，除了域名费用以外并没有花其他的钱。这篇文章记录一下整个的流程。  域名的选择和购买  购买域名的第一注意事项：不要使用中国的域名注册商家或者购买由中国的公司/组织管理的顶级域名。这样做纯粹是为了避免麻烦，主要是不可预期的政策风险和及其复杂的备案流程。即使你像我一样只是一个遵纪守法的好公民，这一整套流程下来，钱和精力都要耗费不少。具体的来讲，首先不要购买  的域名，其次不要选择中文域名，最后，在其他域名之间选择时，记得先去  查询一下你要购买的顶级域名的管理者到底是何方神圣，省得后悔。比如，本站的新域名的顶级域名  就是一家江苏省的公司管理的，这也是我购买以后才发现，真是后悔不迭。  其次，要注意「第一年价格」和「续费价格」，有的域名第一年很便宜，但之后续费就飙升到几十乃至上百美元，另外还需要注意各种附加服务，提防不小心选择到自己不需要的东西。  我选择的域名注册商家是 ，主要原因是它支持支付宝支付。选择和购买很简单顺畅，毕竟没有一个商家会在用户付款的路上添堵。然而，相比于它现代的选择购买界面：  !  它的后台管理界面似乎让你回到了 15 年前：  !  以至于我第一次进入时以为自己被什么野鸡商家骗了钱（  接下来在右边第二个「Domain Manager」里面确认你的域名即可。  !  Render  Github Pages 其实已经很好了，但是由于众所周知的原因，中国境内访问它时不时会被阻断和劣化。所以需要另外一个部署服务来「加速」。有不少教程推荐使用 Netlify，但是它很荣幸的在我所在的区域被 reset 了。所以我选择其他替代方案。  其实这些服务，Netlify 也好，Render 也好，对于我这样的用户来讲都是大同小异的。我用不到复杂的功能，只是作为一个静态站点同步和部署来用。  直接在注册登录，如果使用 Github 登录，可以直接快捷的绑定 repo。选择创建一个新的 Static Site，然后点击右侧的 「Configure account 」绑定 Github 帐号里面的相应 repo 点击 Connect 即可。  !  然后就是配置。你需要起一个名字，它同样是一个二级域名：。不过既然接下来要自定义域名这个也无关紧要。我的站点是完全本地生成后 push 到仓库的，所以没有 Build Command，Publish directory 则是根目录 。默认情况下每一次对源 repo 的 push 都会触发一次更新*，不需要手动设置。  !  接下来是等待部署。等到部署完成后，就可以访问了。同时，状态变成这样：  !  此时可以访问  访问了。这种情况下它相当于是一个类似 Github Pages 但是略微加速。  Cloudflare  使用它不仅仅是出于防止 DDOS 或者的考虑，<del>毕竟 CDN 能减速。</del>其实这反而是次要的考虑。要使用 Cloudflare ，首先需要把域名的 nameserver 转移到 Cloudflare 那边去。Cloudflare 注册以后会有一个向导，一步一步来就行了。主要是 namesilo 那边。你需要先勾选复选框，再点击：  !  然后把原来的删除，添加 Cloudflare 给你的：  !  接下来是 CF 这边，DNS 缓存的全球更新需要一点时间，所以需要等一会儿。接下来就是设置解析地址，点到你的域名，DNS 设置里面添加。DNS 记录可以理解成一个 K-V 对，主要需要知道的三种记录类型：  - A : 域名 -> IPv4 地址 - AAAA : 域名 -> IPv6 地址 - CNAME : 域名 -> 另外一个域名  添加好相应的域名即可。注意在导入站点的时候，会发现有几条不认识的 A 记录，那是 Namesilo 的广告页面，删掉就行。添加  记录可以使用中国境内的 VPS 地址也可以正常访问，但是有合规性风险，不建议尝试。「要么全是(中国)境外，要么全是(中国)境内」，不要混着来。  !  所以，访问  就会相应的跳转到  那边去。但是，此时还是不能够正常使用，因为 Render 那边的  还没有设置。回到 Render 的 Dashboard 里面找到你的项目，在 Settings 里面，添加自定义的域名即可。需要等待一会儿 DNS 刷新以及 Render 处理证书。最后的状态是这样的：  !  那么就大功告成啦！   其实 Render 还支持免费(有大小和时间限制的) PostgreSQL 服务和 Web Service 服务，完全可以折腾一下搞一个评论功能，把白嫖进行到底（", "url": "/articles/博客迁移从域名到部署.html"}, {"title": "GNU・Parallel使用例", "content": "uuid: \"23d00329-9a40-41dc-96e4-673f89a6d1b6\" title: GNU・Parallel使用例 date: 2023-02-19 category: 整理   当需要并行处理一堆东西的时候，有时候会考虑 ，但它真的很复杂，而且总的来讲比较混乱，最好的办法不是从头到尾学一遍，而是按照例子去操作。官方文档也考虑到了这个问题，提供了，本文是对这些例子的转译，顺便添加一些注解。注意，这里只保留了我认为有用的例子，因为这样的工具实在不需要太过复杂的运用。  首先写一个验证程序，显示  到底是怎么给程序添加参数的：    替代  使用  很简单，比如你有很多 html 文件要压缩：    当然也可以    区别就在 parallel 是并行的，使用 ：    而使用 ：    可以看到  同时运行 四个程序，只花了一秒。这也是为什么要用  的原因。所以，同样的，如果碰到视频转码之类的耗费时间的任务，使用  能加快速度不少。  简单网络扫描器    由此可以过滤出返回数据的目标。在这个例子里面，一是要注意换行符号用来分割参数，二是注意使用  来包含每一次的参数。另外  参数用来控制每一批的操作数量。  从命令行读取参数   可以从命令行读取参数，而不是一定要找 。例如第一个例子也可以写成：    但是只能压缩目前级别的文件。命令行参数同样可以使用 ，例如使用  转码：    在这里， 是「取点号之前的字符串」，而  则是分割。    突破参数长度限制  有时候你会碰见这样的问题：    这是因为文件太多了，超出参数长度限制。 传统的方法是使用 ，但也可以使用 ：    这会给每一个操作单独开一个程序。你可以把每一个的参数加到允许的最大范围来加速操作：    内容替换  使用    或者    来删除 pict0000.jpg 到 pict9999.jpg。第一个版本允许  10000 次，第二个给每一个允许的  添加刚好不至于突破参数长度限制的参数，更加快速，也可以这样做：     的作用是，如果多个作业并行运行，则将参数平均分配给作业。   计算密集型作业  你可以使用  来给图片制作缩略图：    这个版本则能够充分利用你的 CPU：    也可以递归的来处理所有的文件：    如上所述，使用  来获取文件名，所以如果你想要 ./foo/bar_thumb.jpg 的文件名，这样做：    将所有  变成 ，并放到同一个目录：    替换和重定向  你有很多  文件，你想要获得未压缩版本。你可以这样：    使用  的版本如下：    你需要把  用引号包围。否则这样做：    其他特殊符号也许要使用引号包围。例如：，否则它们会被 shell 解释，而不是传递给 。  多个命令组合  一个作业可以包含若干条命令，它们之间使用  分割：    甚至可以输入一个小脚本：     批量下载不是问题。以下命令会打印出下载错误的 url 和行号：    创建一个具有相同文件名的镜像目录，除了所有文件和符号链接都是空文件。    在文件列表中过滤出不存在的文件：    很长的操作可以写成 shell 函数调用，不要忘记 export -f：    多重来源数据替换  举例：    可以看到它的替换效果类似于笛卡尔积。  移除参数中的特定字符串  如果只有一个后缀名，例如  可以使用 ，同样地，对于诸如  可以使用 ，切记要加上  参数。  举例：    同样地，对于更多的  也可以处理：     对于任意字符串的替换使用  （后缀） （前缀）和  正则表达式：    用这种方法，可以快捷的重命名。再比如给文件加上时间戳：    聚合文件内容  以下命令将会生成文件  到 ：    更好的  和   一般的  循环长这样：    以及  循环：    可以重写成这样：    步进  假如你有以下输入：    你想要这样：    对于保存在文件里面的情况，使用这个命令：    加速快速的任务  在本地机器上启动作业大约需要 3-10 毫秒，如果作业运行时间非常短，这可能是一个很大的开销。可以使用 -X 将小作业组合在一起。例如：    远程运行  要在远程计算机上运行命令，需要设置 SSH，并且必须能够在不输入密码的情况下登录。    要将命令分发到计算机列表，为所有计算机创建一个文件：    然后运行:    其中的  代表本机。  GNU parallel 将尝试确定每台远程计算机上的 CPU 数量，并为每个 CPU 运行一个作业。  <br/>  本文档的部分来源是 ，其许可证为：", "url": "/articles/GNU・Parallel使用例.html"}, {"title": "为什么 OpenAI 并不 Open", "content": "uuid: \"4f81285d-6c9a-46af-a72b-af1bcb736623\" title: 为什么 OpenAI 并不 Open  date: 2023-02-13 category: 杂感   > 正如我们享受他人的发明带来的巨大便利一样，我们也应该乐于有机会让自己的发明为他人服务，而且我们应该免费并慷慨地这么做。 >           ——本杰明・富兰克林  40 年前，我们的先辈在这个星球上创立了自由软件运动，接近半个世纪的发展后，其成果深刻而全面的改变了我们的数字世界。  而现在，我们面临着另外一场战斗。 GNU 工程的先辈们对抗着私有软件，而眼下这场战斗的敌人是「私有 AI」。它考验着我们能否把握住自己和未来几代人计算的权利，这场看不见的战斗可能要在很久之后──直到事态已经无法挽回的时候──才能够被大众注意到。  自然，这里谈论的并不是有关失控的人工智能向人类城市发射核导弹，这样的危机未来自然有人会谈，眼下这场战斗对抗的形式难以察觉，却无所不在。理查德·斯托曼在其文章中用一个假想的历史故事描述了失去了阅读权利的社会图景，幸运的是，我们并不需要另外一部小说或者一个故事来描述我们被私有 AI 控制的社会。任何一个看过诸如 《银翼杀手2049》 或玩过 《赛博朋克 2077》 的人都不难想象出一个被巨型企业所控制的社会的图景，而不幸的是，今天，这样的巨型企业正在成型。  随着 ChatGPT 在，其背后创造这一超越任何产品用户增长速度的历史性记录的公司，OpenAI，也获得了资本的青睐，然而，这家公司以及其研发的人工智能依旧是私有的。  OpenAI 并不像其名字中那个极具迷惑性的「Open」字眼所暗示那样，是开放的。其产品要求美国手机号码注册，而其最近开始提供的分级付费服务更是为其「ensure that artificial general intelligence benefits all of humanity」的宣传添加了一个可笑的注脚。当然，奢求一个商业公司无偿的为大众提供服务是幼稚的，但当我们考虑 OpenAI 这样的公司，其营业模式和研发产品的投入则向我们揭示了现代的人工智能是如何变得「不自由」的。  如同汽油对于汽车，源代码的可获得性和控制权对于软件一样，创造和控制一个人工智能模型，最重要的三个方面是算法，计算力和数据。而很遗憾，我们的手中几乎没有其中任何一项。先进的，能够创造出成规模的大型模型的人工智能算法要么在博士和教授们的论文中，要么在签署了重重保密协议的公司实验室中，而高中生宿舍里运行着 Tensorflow 的笔记本的计算能力也不可能与 24 小时运行的成千上万台专用机器相比，商业公司可以获得广泛的，海量的数据，并能够在与大量用户的交互中获得反馈和进行修正，而个人只能投入自己有限的精力寻找参差不齐和少量的数据。与自由软件运动不同，大型人工智能模型的开发在可见的革命性的技术发展出现以前，依靠的不仅仅是程序员的脑力和一腔热血，其背后起到支撑作用的，是商业公司海量的投资。  在这三者中，最难以获得的，也是最为关键的，是计算力。毫不夸张的讲，谁掌控了计算力，谁就掌控了人工智能模型创造和训练，而鉴于人工智能在未来社会中的广泛运用，这一掌控事实上也就是掌控了整个社会。而不难想象，拥有这样巨大的影响力的巨型企业将会以何种方式影响和操纵社会。这并不是危言耸听，看看 DMCA 吧，回顾一下已经习以为常的 DRM 和「安全启动」。掌控了海量计算力的巨型企业，压倒和吞并小的企业，垄断计算能力，雪球一样越滚越大，直到成为笼罩在整个社会上的令人战栗的老大哥。  对抗私有 AI 及其发展模式的战斗业已展开，这场战斗的规则是赢者通吃。目前，我们的敌人正在联合起来，并且不断增长 ──── 无论是处于追逐利益还是追逐其他什么东西 ──── 并在投资和估值令人眼花缭乱的上扬中不断壮大，而我们却依旧没有任何清晰的战略和方法来对抗它们。  而就在 2023 年 1 月，OpenAI 即将，使其估值达到 290 亿美元。", "url": "/articles/为什么OpenAI并不Open.html"}, {"title": "CROS，Cookie与hapi", "content": "uuid: \"86894309-f881-4d14-b82f-6f3e755f2866\" title: CROS，Cookie与hapi date: 2023-02-07 category: 技术   最近做项目，用到了  作为后端，但前端是放在不同域名的静态页面，于是喜闻乐见的遇到了无数 CROS 问题。虽然以前也遇到过，并且用各种瞎猫碰到死耗子的方法绕了过去，但没有真的留意过，直到这次需要大规模用到 CROS 请求，还要跨域传送 Cookie，这才仔细学了一下。  CROS，全称是 Cross-Origin Resource Sharing，跨源资源共享。就是说，一个网站上的脚本要访问不在同一个域名的资源。主要的 CROS 请求来源有 XHR 请求，  调用以及字体文件。  CROS 有两种，一种是「简单请求」，一种是「复杂请求」。简单请求，简单的来讲就是请求方法是 ，，，并且请求的  里面没有奇奇怪怪的自定义数据，里面的标头只能是。第二种是「复杂请求」，它需要「预检」。也就是对这个资源发送一个  请求，所以在 F12 工具里面能看到两个请求。  简单请求  简单请求中，浏览器会给目标服务器添加标头  来表明来源，目标服务器必须要有一个  标头，表示允许请求，不然请求的资源会被浏览器拦截。这个拦截在 js 层面是无法检测的，但会在浏览器 Console 中显示出来。具体的显示是：    作为服务器端，必须在返回的头中带有  字段。如果是公共的 API 和资源，直接设置为 「*」即可，否则需要添加对应的调用方地址。  举例来讲，对于一个这样的请求：    对应的 hapi 路由应该这样写：    或者这样：    这样就可以了。  复杂请求  复杂请求必须首先使用  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。在开发人员工具的「网络」中会显示其 Method 是 ，之后才是真正的请求，显示为 。其中  是请求的方法。  对于 Preflight 请求，需要两个字段： 和 。前者是实际请求的方法，后者是实际请求所携带的额外头部。  对于服务器相应的 Preflight 请求，有四个额外字段：，，，。分别为允许的域名，允许的方法，允许的额外标头，可供缓存的时间长短（秒）。  之后进行实际请求，其标头和一个简单的 CROS 请求一样。    对于浏览器的 fetch 请求，请求头会自动添加。  跨域 Cookie  正常情况，一个站点的 Cookie 只能一个站点使用。想要跨站点发送 Cookie 需要：  1. 在  的请求中设置  为 ; 2. 服务器的相应中需要有  标头; 3. 当响应的是附带身份凭证的请求时，服务端必须明确  和  的值，而不能使用通配符。  对于服务器，首先需要设置好 Cookie，hapi 中的 Cookie 叫做 ：    对应 router 的 options ：    设置 Cookie 则是：    参考  -  -  -", "url": "/articles/CROS，Cookie与hapi.html"}, {"title": "Svelte 基础速查", "content": "uuid: \"ad498778-ccfb-4be7-97af-bd60ac5939f9\" title: Svelte 基础速查 date: 2023-02-02 category: 学习   记录一下 Svelte 的概念和基础，省得每次去开教程了。  创建项目  注意  和  不一样。用  选择就行了。   文件结构  一个 Svelte 组件保存的后缀名是  内容一般是三个部分，脚本部分，HTML 部分和 CSS 部分。CSS 是只作用于这一个组件的。各个组件可以互相引用，就像 React 那样 Import。举例：    - 如果一个标签的属性和值相同，可以简单书写，例如：。 - 如果变量包含的是 HTML，可以使用  标签转义，例如：<strong>Hello</strong>。如果引入了  这样的处理器，可以直接  这样渲染。  事件处理  给 HTML 元素加上  标签注册事件处理器：    也可以使用简略形式：    使用  来保持引用，这样一个变量改变了，另外一个也能够随之改变。这是一个 ，就是声明了一个特殊的叫做  的标记。     的更新取决于是否有 assignments 也就是赋值操作，所以单纯的写  不会触发更新。你还需要  才行。对于数组，可以便捷的采用  来更新。      用  来给处理器加额外设置，就像这样：    多个可以叠加，类似  。  -  ：就是  。 - ：同样地，相当于调用 。 - ：这个处理器只使用一次。 - ：只有在  是元素自己时调用。 - ：只有  是  才调用。比如  就不是。  消息传递  dispatch  组件之间的消息传递就是所谓 （这个词中文含义是 调度，派遣，发送 的意思），比如说有一个 Outside 组件，里面包含了一个 Inner 组件，Inner 组件想要让外部组件更新一项信息，如果用简单的 React 的话那就是把外部组件的对应处理函数作为 Inner 的一个 prop 传送进去，让它调用。如果使用  方法的话，就是 Inner 向外部组件发送一个消息，告诉他发生了什么，再由外部组件决定干啥。  为此，Inner 组件需要引入  来便捷的创建标准的消息。而外部组件需要对于每一种类的消息，定义一个  的处理器来接收消息。举例如下：  Inner：    Outside：    接受到的消息是这样的结构，主要关心的数据就是里面的  和 ：  !  夹心饼干  有时候会遇到「夹心饼干」一样的组件堆叠，最里面的组件要传递信息给最外面的组件，于是要穿越中间很多层， 给被穿越的那些组件提供了简单的数据传递写法。一个没有处理器的  会转发一切到上层：     不仅仅可以转发自定义的消息，对于 DOM 事件也可以转发。所以可以对最内层的某个按钮的 click 事件一层层转发到最上层处理。  组件的 props  就像 React 的 props 一样，不过是以  变量的形式定义的：    其他组件调用它是这样：    对于有很多属性的组件，可以用简略的方法定义一个  放进去。假如有一个组件有四个 props ：，，，：    按需渲染  if    each  循环，类似于 React 中的  函数：    如果循环的对象是一个复杂的 ，那么可以直接解构。假如数据  是  类型的数组，那么可以这样：    默认情况下，当改变  中的数据时，最后一个项目会被增加或者删除，然后更新每一个更改的项目。也就是说，它是倒着更新的，所以，需要指定一个 。    Promise  直接给  包装一层，很方便：    绑定  通过绑定，可以更好的处理一些交互式元素，特别是  类的处理：  input    如果不使用  的话，就需要捕获输入事件，定义一个处理这个事件的函数，再更新数据，比较繁琐。  对于一般的数据，使用 ，对于 checkbox 是否选中，使用 。如果你需要绑定更多值，则可以使用  将 value 属性放在一起使用。那么多个组件就共享一个数据源了。 只能用于 checkbox 和   对于  中的元素，可以挨个绑定，详见。  select     的内容是  的类型。  可编辑元素    尺寸绑定  每个块级标签都可以对 、、 以及  属性进行绑定：    这些绑定是只读的，更改 w 和 h 的值不会有任何效果。  生命周期处理  -  fired after the component is rendered -  fired after the component is destroyed -  fired before the DOM is updated -  fired after the DOM is updated    在每个组件第一次渲染之后触发。    在  中可以注册 async 函数，例如在里面 await fetch 什么东西。如果注册函数返回一个函数，这个函数将在组件销毁时触发。     允许清理数据或停止我们可能在组件初始化时启动的任何操作，例如计时器或使用  的计划周期函数。    调试  使用  tag。  参考  1.", "url": "/articles/Svelte基础速查.html"}, {"title": "使用 TeXmacs 排版作业", "content": "uuid: \"ac2beaa1-e98c-4108-9d0c-06f035cbaad3\" title: 使用 TeXmacs 排版作业 date: 2023-01-31 category: 杂项   <style>  .latex sub {   vertical-align: -0.1ex;   margin-left: -0.1667em;   margin-right: -0.025em; }  .latex sub, .latex sup {   font-size: 0.9em;   text-transform:uppercase;  } .latex sup {   font-size: 0.85em;   vertical-align: -0.2em;   margin-left: -0.26em;   margin-right: -0.05em; }  </style>  我被 LibreOffice 折磨了五年。  为了替换它，我尝试了 Markdown，但它的功能太简单了，尝试了 <span class=\"latex\">L<sup>A</sup>T<sub>E</sub>X</span>，但是首先我没学会，其次我从来没有成功的让它显示中文字符，并且它的大小也太夸张了。最后我找到了 。我以前也不是没有听说过，但是受到它的名字的误导，我认为它是一个「使用 Emacs 的 TeX 编辑器」。其实它和两者的关系不大。   的软件源里面没有，需要安装。  在使用 TeXmacs 之前免不了需要解决一些疑难杂症。都和中文有关。首先是文档语言无法选择中文的问题，你需要在首选项中将界面语言改为中文才行，同样的，如果需要选择日文就把界面语言改为日文，其他各种不能用键盘上的字母表达的语言操作类似。其次是输入中文乱码的问题，在有些系统上，默认的中文字体  是没有的，所以会指定到  的默认字体，自然无法显示中文。你需要给 TeXmacs 添加字体才行。所幸官网给出了中文字体包：。你需要把它解压到  里面。最后目录结构应该是这样的:    不要忘记添加以后运行  清除缓存，然后就可以使用了。另外建议把宋体楷体什么的也安排上，直接用  的包就行。  除此以外，在保存时也会遇到问题，焦点会强制集中在一个什么都没有的窗口上，不过不影响后面文件选择窗口的操作，记得输入文件名。它保存的是纯文本文件，内容格式类似于 。  !  下面记录一些常见的操作。  内置的模板  使用  来选取预定的样式，直接选择  即可。它包含了标题，作者，摘要之类的东西。可以自己改进，但是它的模板似乎是用类似 scheme 的 dsl 写的...  文章结构  标准的文章结构是标题，摘要，正文等等。关键词是放在摘要里面的，所以在摘要环境的菜单里面选中。  !  文本格式  和  之类的软件类似，菜单上的选项是不言而喻的。不过如果不想离开键盘，还可以使用  命令。  命令都以  开头，输入以后可以自动补全。诸如  ，， 之类的文本格式可以直接输入。步骤是输入  再在蓝色尖括号中输入指令，按下回车就行。输入完毕以后移动到块以外。常见的格式如下：  !  然后是给文章添加节，同样是使用  命令。用  添加节， 添加子节，还有  之类。添加以后会自动更新，所以不用担心序号错乱问题。  添加目录  在想要添加目录的地方，使用  命令，接下来按回车，再在  后面输入  即可。命令看上去是这样的：。接下来回车就行。但是目录不会自己更新。需要在  中手动更新一下。  参考文献的添加  首先需要一个  文件。它算是一个引用数据库，在主文档里面引用它里面的内容即可。比如说有一个  文件是这样：    然后在  中选择这个文件。注意：bibtex 文件必须在同一个目录！。接下来在需要引用的地方使用  ，然后刷新两次即可。  注意事项：  1. Bibtex 文件的后缀名必须是  2. 引用标签不能是中文，否则乱码  !  不管是添加表格也好，添加其他内容也罢，当焦点在对应的元素环境里面时，第三列工具栏就会显示为当前环境的相关工具。比如表格就会显示添加行列的按钮等。  我的应用场景是对排版元素要求不高的电子版作业，考虑到我的专业，基本没有公式和复杂表格的需求，所以用起来还是绰绰有余的。但是毕竟公式编辑是它最激动人心的功能,所以还是看一眼。  公式编辑  直接键入  进入数学模式，然后就可以编辑了。  !  好吧，总的来说我应该是用不上的。  参考  -  -  -", "url": "/articles/使用TeXmacs排版作业.html"}, {"title": "旧式书信整理2", "content": "uuid: \"ec07d825-9c76-442d-85f5-7deaf5ab889a\" title: 旧式书信整理2 date: 2023-01-28 category: 整理 project: \"旧式书信整理\"   来源：《分类详注新尺牍大全》，袁韬壶 编著，群学出版社，1946 年，OCR + 整理，仅保留文本，简繁转换准确性存疑。  家书类  <br/>  祖谕孙<sub>（训勉学业规矩）</sub>  <br/>  某孙收阅[^1]。  昨接汝来信。知汝已于月之望日[^2]。进店学业[^3]。身体平安如常[^4]。深为可慰[^5]。惟汝学业伊始[^6]。诸宜勤慎从事[^7]。一切店规[^8]。均当恪守[^9]。凡事须听业师教训[^10]。店中诸位同事先生。及师兄等辈[^11]。应以恭敬和睦相待。晚间店务有暇[^12]。须随时学算习字[^13]。切不可怠惰疏忽[^14]。是为至要。余[^15]在家安好。汝父昨亦有安信[^16]寄来。拟下月初旬[^17]。方可回家云云[^18]。汝母及弟妹等[^19]亦各平顺。毋庸[^20]挂念。此付知之。  <span style=\"float:right\">祖字</span>  <br/>  孙禀祖<sub>（禀告学业事）</sub>  <br/>  祖父大人钧鉴[^21]。  敬禀者[^22]。顷[^23]接来训。谨已读悉[^24]。并知大人福体康健[^25]。&nbsp;&nbsp;母亲及弟妹等。均各平安。不胜欣慰[^26]。&nbsp;&nbsp;父亲处今日亦寄去一禀。免在远地罣念[^27]。在店中。诸事自当勤慎。决不敢稍存怠忽。晚间遇公务[^28]闲暇时。字算两项[^29]。常在灯下练习[^30]。并蒙业师某先生随时指教[^31]。尤为可感[^32]。店中同事诸君。亦均肯照顾。叨益[^33]良多。一切之事。<span style=\"font-size:small\">孙</span>当谨遵[^34]大人训谕而行。毋劳慈廑[^35]。余容后禀。专肃。敬请崇安。  <span style=\"float:right\"><span style=\"font-size:small\">孙儿</span>某某顿首</span>  <br/>  祖母谕孙<sub>（述近状）</sub>  <br/>  某某孙儿收读[^36]。  昨由邮局递[^37]来一信。并附家用洋拾元。均[^38]早收到。知汝在店安好。<span style=\"font-size:small\">余</span>及汝母闻之。都觉安心[^39]。家乡百物昂贵[^40]。米珠薪桂[^41]。世境益[^42]觉艰难。持家[^43]正非易易。惟有量入为出[^44]。俭省[^45]度日而已。汝母病已步痊[^46]。胃口亦较前为佳[^47]。现仍医药调理[^48]。想不日即可痊愈[^49]。无庸挂虑[^50]。今年店中生意如何。想入冬以来。谅必渐有起色[^51]。汝在外一切冷热。切宜小心为要[^52]。余不多嘱。此复收目。  <span style=\"float:right\">祖母字</span>  [^1]:     阅音月，看也。言收看此信也。  [^2]:     十五日谓之望。  [^3]:     学生意谓之学业。  [^4]:     如常，同于平时也。  [^5]:     慰音尉，宽安也。  [^6]:     伊始，起初也。  [^7]:     言许多事体，都要勤俭谨慎也。  [^8]:     店规，店中规矩也。  [^9]:     恪音，恪守，谨守也。  [^10]:     凡事，一切事体也。  [^11]:     诸位，众位也。店中朋友，谓之同事。  [^12]:     暇，空闲也。  [^13]:     习常，学也。  [^14]:     怠惰，不勤力也。疏忽，不谨慎也。  [^15]:     余，我也。  [^16]:     安信，平安家书也。  [^17]:     初一至初十，谓之上旬。  [^18]:     云云，犹云所话如此也。  [^19]:     等，一切也。  [^20]:     毋庸，不必也。  [^21]:     钧，重也。系尊称之词，或用慈鉴膝前等字亦可。  [^22]:     凡下辈致信于长辈，须用敬禀者三字，言恭敬禀告也。  [^23]:     顷，即刻也。  [^24]:     读悉，读知也。  [^25]:     康，安也。健，强也。  [^26]:     欣慰，言心中欢喜而宽安也。  [^27]:     罣念，与挂念同。  [^28]:     公务，事也。  [^29]:     两项，两件之事也。  [^30]:     练音理，学习也。  [^31]:     指教，指示教导也。  [^32]:     尤，更也。  [^33]:     叨益，受其益处也。  [^34]:     谨尊，敬依也。  [^35]:     慈廑，仁慈之思念也。  [^36]:     谓收此信而读之也。  [^37]:     递，传送也。  [^38]:     均，皆也。  [^39]:     余，我也，觉，知及也。  [^40]:     昂，高也。言家乡百种货物价目，高贵也。  [^41]:     米如珠，柴如桂，喻柴米之价甚贵也。薪音新，柴也。  [^42]:     益，更加也。  [^43]:     持家，管理家务也。  [^44]:     量，度也。言只可酌量所入之进款，为用出之数目也。  [^45]:     俭省，不奢用妄费也。  [^46]:     言病已逐步见痊也。  [^47]:     言吃饭之胃口，亦比从前好些。  [^48]:     现在仍旧请医服药，以调养其病也。  [^49]:     不日，不多几日也病已退尽曰全愈。  [^50]:     言不必挂念忧思也。  [^51]:     起色，犹云生色也。  [^52]:     诸，多也，宜，应当也。", "url": "/articles/旧式书信整理2.html"}, {"title": "旧式书信整理1", "content": "uuid: \"3b4b4117-f9bc-4a49-937b-5fefbfc12f9c\" title: 旧式书信整理1 date: 2023-01-25 category: 整理 project: \"旧式书信整理\"   来源：《分类详注新尺牍大全》，袁韬壶 编著，群学出版社，1946 年，OCR + 整理，仅保留文本，简繁转换准确性存疑。  学界类  贺友毕业  <br/>  某某仁兄伟[^伟]鉴。  正怀[^怀]旧雨[^旧雨]。忽观朵云[^朵云]。不觉喜从天外飞来。迨启[^启]封展视。知此次贵校毕业考试。 阁下果居最优等之列。[^0]令人可钦可慕。素仰阁下才识优[^优]长。品性醕纯[^醕纯]。将来对于教育前途。定可增[^增]进无穷幸福。而此时之实至[^至]名归。如愿以偿。犹其小焉者耳。年假伊邇[^伊邇]。想荣旋[^荣旋]在即。良晤匪遥[^1]。当可共图一番畅叙[^叙]矣。专此奉达。敬候学祺。并颂文明进步。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某手上</p>  <br/>  校长辞职  <br/>  某某先生钧鉴。  日前趋诣台端[^2]。適值[^適值]大驾公出。未获面聆教言[^3]。怅甚。敬启者，<span style=\"font-size:small\">某</span>自承乏某校职务以来[^4]。迄今三载。自愧才疏学浅。于事无裨[^无裨]。兼近来体弱多病。精力苦于不济[^不济]。恐难胜此重任。故不得已自行告退。伏乞俯[^fu]如所请。另选贤能以重教育而专责任。临颖曷胜悚惶待命之至[^5]。专肃。敬请勋祺。诸维崇照。  <p style=\"float:right\">某某谨启</p>  <br/>  托同学续请病假  <br/>  某某同学兄大鉴。  别来倏逾[^倏逾]三星期矣。迩想文明道德。与时俱[^俱]进。为颂无量。<span style=\"font-size:small\">某</span>为二竖[^6]所苦。告假返里养疴[^养疴]。迄今尚未痊愈。时觉困倦乏[^乏]力。不克到校。未免旷废课程[^课程]。深为焦灼[^焦灼]。因念目下假期已满。拟再绩[^绩]假十天。用特耑函奉懇。祈向&nbsp;&nbsp;校长先生处。转达下忱[^忱]。并懇代为请假是感。诸费清神。容当面谢。专此布懇。顺颂学祺。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某鞠躬</p>  <br/>  约友同伴赴校  <br/>  某某大兄毅[^毅]鉴。  连朝风雨。春寒料峭[^7]。每拟出门走访。奈泥泞[^8]路滑。行不得也哥哥[^9]。令人闷损殊甚。未识阁下近时作何消遣[^10]。各学校不久即将开课。<span style=\"font-size:small\">弟</span>今春仍赴省垣[^11]某校肄业。与贵校近在咫尺。倘能结伴偕行[^12]。一路携手谈心。诚为快事。如蒙许可[^13]。请先示以行期。俾[^14]可预备一切也。专此布达。即颂文祺。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某手奏</p>  <br>  询问女学校应用何种教科书  <br/>  某某先生阁下。  自违麈教[^15]。弥切葵忱[^16]。比维荣问日昭[^17]。兴居纳福。慰如所颂。启者。<span style=\"font-size:small\">敝处</span>地方僻陋[^18]。风气尚未开通。小学校已成立者。不过五六所。皆粗具形式[^19]而已。若女子学校。则更付诸阙如。近由同志发起[^20]。创办女子初等小学一所。业已组织就绪[^21]。惟此项初等女学程度尚浅。以何种教科书最为适用[^22]。因念阁下热心教育。富[^23]有经验。务望不吝[^24]赐教。俾得遵循[^25]有自。 曷胜感幸之至。专此布达。敬颂撰祺。诸惟惠照不一。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某上言</p>  <br/>  报告学校年终考试  <br/>  某某我兄尊右。流光如驶[^26]。转瞬又居残年[^27]。辰维時祉多绥[^28]。欣以为颂。启者。<span style=\"font-size:small\">敝</span>校下学期。业已发表[^29]。<span style=\"font-size:small\">弟</span>各科分数。平均[^30]在八十分以上。幸列于最优等。其中以算学国文两门。成绩稍优[^31]。盖<span style=\"font-size:small\">弟</span>平时所注重者。尤在于斯[^32]。此次幸获[^33]美满之效果。稍慰平时之希望[^34]。想我  兄闻之。当矣代为欣幸耳。知关垂注[^35]。谨以报闻。年假在即[^36]。不日即欲返里。再当面聆[^37]教益。余不琐陈[^38]。专上敬颂文祺。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某谨泐</p>  <br/>  同学偶犯校规请免黜退  <br/>  某某校长先生台鉴。  迳启者。近因为同学某君某某。以某事偶犯校规[^39]。恐未免有黜退[^40]之虑。窃[^41]念先生尊重教育。奖惩并施[^42]。用此不屑之教诲[^43]。予[^44]以相当之儆诫。此固正当办法。谁曰不宜[^45]。<span style=\"font-size:small\">某</span>等又何敢以不情[^46]之请。上渎[^47]清德。惟<span style=\"font-size:small\">某</span>等与某君同学。迄今已越两载有余[^48]。知其素性戆[^49]直。有时或未免失于自检。此次违犯规则。事后彼亦深自追悔。引谴未惶[^50]。伏乞先生宽其既往[^51]。曲予矜全[^52]。使某君不致半途[^53]而废。前功尽弃。此则先生成人之美[^54]。为某等所馨香祷祝者耳。专肃。敬颂教安。诸维崇照。  <p style=\"float:right\"><span style=\"font-size:small\">学生</span>某某鞠躬</p>  <br/>  聘请会计员  <br/>  某某先生大鉴。  久仰芝晖[^55]。时殷葭溯[^56]。辰维与居曼[^57]福。至以为颂。兹启者。<span style=\"font-size:small\">敝校</span>会计一席[^58]。向[^59]归某君办理。现因病去世[^60]。此席尚付悬如。因悉阁下办事敏捷[^61]。于经济学[^62]又素有经验。用敢奉屈高材。倘蒙不弃[^63]。乞即翩莅止[^64]。是所盼祷。专上。顺颂台安。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某鞠躬</p>  <br/>  教员辞聘再致函劝驾  <br/>  某某先生阁下。前陈芜函[^65]。请秉[^66]教鞭。正在跂望[^67]时。忽接诵来翰[^68]。具见虚怀若谷[^69]。谦而弥光[^70]。令人益深钦仰。伏念先生品学兼优[^71]。声华[^72]卓著。夙为学界所推崇。春风化雨[^73]。定能造就人才。还祈俯[^74]如所请。慨然出而担任。不但全体学生。一致表示欢迎。且于<span style=\"font-size:small\">敝校</span>前途。并可增进无穷幸福。用再专函劝驾[^75]。无任翘盼之。至肃此复请撰祺。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某谨上</p>  <br/>  荐教员  <br/>  某某先生大鉴。  久违光采。时切心仪[^76]。比维时祉[^77]清嘉。文祺[^78]畅达。式符[^79]颂忱。昨某君来此。述及阁下提倡[^80]教育。筹备经费。拟在某处开办某某学校一所[^81]。欣甚佩甚。惟贵校组织伊始[^82]。各科教员。谅必尚在需[^83]人。兹有<span style=\"font-size:small\">敝友</span>某君某某。前在某某师范毕业。程度颇优[^84]。于国文算术等科。尤为擅[^85]长。尊处如欲聘[^86]用。<span style=\"font-size:small\">弟</span>愿代为绍介。如蒙许可。希即示如[^87]。是所感盼。专布。敬颂大安。  <p style=\"float:right\"><span style=\"font-size:small\">弟</span>某某手启</p>  <br/>  托同学返校时购带书籍  <br/>  某某同学兄毅鉴。  别经两旬[^88]。近况谅佳。知我兄假期将满。想不日即当返校[^89]。大驾道经沪江时[^90]。烦向某书局代购数理精蕴一部[^91]。计价若干。恳乞暂为填。俟到校后面奉可也。专此恳托。即颂潭祺。  <p style=\"float:right\"><span style=\"font-size:small\">小弟</span>某某手启</p>  [^伟]:     伟，高大貌。  [^怀]:     怀，思念也。  [^旧雨]:     旧雨，老友之称（杜诗小序注），旧雨来，今雨不来。  [^朵云]:     朵云，谓书信也，覩见也。  [^启]:     启，开也，谓开信翻看也。  [^0]:     学科分数，在八十分以上，为最优等。  [^优]:     优，美也。  [^醕纯]:     醕，厚也，纯，正也。  [^增]:     增，加也。  [^至]:     至，到也，谓做到真实功夫，而名誉自可归之。  [^伊邇]:     伊邇，近也。  [^荣旋]:     称人回里曰荣旋。  [^1]:     谓会面之期不远也。  [^叙]:     相会曰叙，（王羲之兰亭序）亦足以畅叙幽情。  [^2]:     谓走  处也。  [^適值]:     適值，正逢也。  [^3]:     未获，不得也，聆，听闻也。  [^4]:     乏，缺也，谦言乏人之故，而我充当此职也。  [^无裨]:     无裨，无益也。  [^不济]:     不济，不足也。  [^fu]:     俯，垂下貌。  [^5]:     笔毫曰颖，临颖，谓临写信时也，悚惶，恐惧不安之貌。  [^倏逾]:     倏，忽速也，逾，过也。  [^俱]:     俱，共也。  [^6]:     谓有病也，（左传）晋侯有疾，梦见二竖子。  [^养疴]:     返里，回家也，疴，病也。  [^乏]:     乏，缺也。  [^课程]:     课程，即所修之功课。  [^焦灼]:     焦灼，闷烦也。  [^绩]:     绩，继也。  [^忱]:     忱，心意也。  [^毅]:     毅，刚决貌。  [^7]:     料峭，尖利貌。  [^8]:     泞，深黏貌。  [^9]:     此句系鸟语，即鹧鸪之啼声，鸟语中又有脱袴脱袴，姑恶姑恶等类，皆以声像意也。  [^10]:     消遣，即消空解闷之称。  [^11]:     省城，曰垣。  [^12]:     偕行，共走也。（诗经）与子偕行。  [^13]:     许可，允及也。  [^14]:     俾，使也。  [^15]:     违，背隔也。称人之谈论曰麈教，注见前。  [^16]:     弥切，更深也。心意曰忱，谓心意向慕之切如葵藿之向日也。  [^17]:     荣问，好声名也。昭，明也。  [^18]:     僻陋，偏荒之称。  [^19]:     形式，样子也。  [^20]:     初倡其事，谓之发起。  [^21]:     谓事已办成也。  [^22]:     适用，合用也。  [^23]:     富，足也。  [^24]:     不吝，不鄙惜也。  [^25]:     遵循，依从而行也。  [^26]:     行船曰驶，谓光阴快速也。  [^27]:     谓一眨眼之间，年又将近也。  [^28]:     祉，福也。绥，安也。  [^29]:     事已揭晓，谓之发表。  [^30]:     均，匀也。  [^31]:     功程曰绩，优，美也。  [^32]:     尤，更也。  [^33]:     获，得也。  [^34]:     希望，想望也。  [^35]:     称人俯念之词。  [^36]:     即，就近也。  [^37]:     聆，听也。  [^38]:     余，多也。谓余多之言，亦不细碎布告也。  [^39]:     规，法则也。  [^40]:     黜退，斥而去之也，（孟子）焉往而不三黜。  [^41]:     窃，私也。窃念，云一己之私意也。  [^42]:     奖，赏也。惩，罚也。  [^43]:     （孟子）不屑之教诲者，是亦教诲之而已矣。  [^44]:     予，用也。许与之意。  [^45]:     谁，何人也。言何人敢说此事为不当也。  [^46]:     不情，谓不合情理也。（苏洵辨奸论）凡事之不近人情者。  [^47]:     渎，烦亵也。  [^48]:     迄，至也。越，过也。  [^49]:     （史记）戆哉汲黯也，戆，粗  貌。  [^50]:     谓彼亦自认过失也。未，不及也。  [^51]:     既往，谓已过去之事。  [^52]:     矜全，成全之意。  [^53]:     半路，半途也。  [^54]:     （论语）君子成人之美。  [^55]:     晖，光也。称人之容度曰芝晖。  [^56]:     葭溯，思怀之词。（诗经）蒹葭苍苍，（又）溯洄从之。  [^57]:     曼，长也。  [^58]:     管理财款事务，谓之会计，即帐房之称。  [^59]:     向，从前之谓。  [^60]:     人死曰去世。  [^61]:     敏捷，灵快也。  [^62]:     经济学，谓理财之事。  [^63]:     弃，舍也。（诗经）不我遐弃。  [^64]:     请人到来也。  [^65]:     芜函，自谦为荒芜之书信。  [^66]:     秉，持也。请人作教员之词。  [^67]:     跂望，谓翘足而待也。  [^68]:     诵，读也。来翰，谓来信也。  [^69]:     谓谦虚之心，如空谷之能容也。  [^70]:     （易经）谦尊而光。  [^71]:     兼优，并美也。  [^72]:     声华，声容也。  [^73]:     皆称教化之善也。（孟子）如时雨化之者。  [^74]:     俯，垂下貌。  [^75]:     谓再备此信劝其动身到来也。  [^76]:     仪，景仰之意。  [^77]:     祉，福也。  [^78]:     祺，安也。  [^79]:     符，合也，忱，心意也。  [^80]:     提倡，即兴办之谓。  [^81]:     一所，一处也。  [^82]:     谓其筹办方初也。  [^83]:     需，待用也。  [^84]:     优，美也。  [^85]:     擅，专也。  [^86]:     聘，请也。  [^87]:     希，望也。望其来信示知也。  [^88]:     两旬，二十天也。  [^89]:     返，回也。  [^90]:     道经，犹云路过也。沪江，即上海。  [^91]:     购，买也。数理精蕴，系算学书名。", "url": "/articles/旧式书信整理1.html"}, {"title": "CommonLisp基础-常见操作", "content": "uuid: \"704f2611-4448-4f94-a4c1-7b797aad7a43\" title: CommonLisp基础-常见操作 date: 2023-01-20 category: 学习   本文记录 CommonLisp 的一些常见操作，记住， 是你的好朋友！  字符串操作  首先，在 CommonLisp 中，字符串既是 array 也是 sequence。所以，适用于它们的操作也适用于字符串。因此可以使用相应的操作：    因此，字符串的拼接：    其他 String 类型专有的操作：  创建字符串  使用双引号创建字符串，除此以外，使用  返回一个新的字符串，使用  创建一个给定长度的字符串，如果需要从一个字符串创建字符，使用 ，反之使用 ：    字符串切片  使用  来获取字符串切片，格式为： ：    获取单个字符  除了  以外也可以使用  ，来获取字符串的单个字符，结合  来做到类似  这样的替换：    获取字符的码位  每一个字符都有一个数字和它对应，具体的数字与实现相关，一般就是 Unicode 。 和  类似于 Python 中的  和  函数：    更改字符串  移除和替换  序列类型的标准操作，可以使用以下操作对字符串进行：    字符串拼接  使用  来拼接字符串，需要提供结果类型 ：    如果你有  ，使用  亦可，除此以外，不要忘记  可以用来应对复杂的拼接和格式化操作。  大小写    所有这些函数接收  和  参数指示开始和结束的位置。  注意：,  和  不会修改原来的字符串。但是，如果字符串中没有字符需要转换，则结果可能是字符串或其副本，由实现自行决定。  去除空格    寻找和搜索  在一个字符串中寻找特定字符和在序列中寻找元素类似。使用   和   和  来达到目标，要寻找字符串，使用 ：    类型转换  - string -> integer        使用  来转换，使用  来允许垃圾：        - string -> float        很遗憾，没有内置的方法。外部函数库  可以做到这一点. 它不使用  所以可以安全使用。  - number -> string        使用  来转换，当然也可以使用 ：        字符串切分  很遗憾，还是没有，不过  中提供了解决方案：    输入输出  使用  来从标准输入读取，使用  来输出。除此以外，还可以使用  来打印， 来执行复杂的格式化：  | 形式         | 描述          | 举例                      | |  |  |  | | read-line  | 读取一行        |            | | read-char  | 读取一个字符，多余丢弃 |            | | write-line | 输出一行，自动换行   |  |  没有标准的  之类的函数，你可以定义一个：      类似于  中的 ， 是一个强大的格式化工具。它接受两个必要参数：一个用于输出的目的地,另一个含有字面文本和嵌入指令的控制字符串，紧随其后的是一系列格式化参数。第一个输出目的地是 、、一个流或一个带有填充指针的字符串。如果输出对象是 ，那么就输出到标准输出，也就是 ，如果是 ，直接返回字符串。控制字符串的作用类似于 C 中  格式字符串的作用，本质上是一个用来描述格式的语言。<del>这就导致了很容易写出类似动物反刍噪音一般无法理解的东西</del>。  与 C 不同，所有的格式指令以  开头，而不是以  开头，指令不区分大小写。~之后的是单个英文字符的指令，以及一个可能的前缀，这个前缀可以是多个字符，使用逗号分割。  常见指令列表：  - ：消耗一个格式化参数，转换成<del>它认为人类可读</del>的形式。例如：        - ：和  效果类似，但将输出生成为可被  读回来的形式：        -  和 ：产生新行。 总是产生一个换行,而  只在当前没有位于一行开始处时才产生换行。可以添加前置参数指定要产生的换行的数量。例如： 将会产生 5 个空行。  - ：产生波浪线，在之前使用数字控制产生多少个波浪线。  - ：字符。      打印单个字符，可以使用控制字符来控制特殊字符的展开方式：      - 直接使用打印字符本身：     - 使用  修改符号打印特殊字符的名称：     - 使用  修改符号打印字符的 lisp 表示方式：     -  和  可以混合使用，并非所有的 Lisp 都实现了  指令的这个方面。  - ，， 和 ：整数输出。    ：添加  在千位数字之间添加逗号；田间  总是显示正负号，第一个前置参数可以指定输出的最小宽度,第二个参数可以指定一个用作占位符的字符，第三个参数是给  作为分割符号的符号，第四个参数是  分割下每一组数字的数量。举例：            参数是 ，四个参数分别是 ，，，，以及开关  和 。    另外三个   和  和  类似，但输出分别是 16 进制，8 进制和 2 进制：        - ：更加复杂的整数控制。       可以输出为 2-36 进制，第一个参数即为输出进制数。其他参数和之前相同，另外，在没有第一个参数时，拼写成英文单词，按照选项的不同，还可以拼写成罗马数字。      -  和 ：浮点数      ：使用计算机科学记数法，十进制输出，第二个参数控制在十进制小数点之后打印的数位个数。 选项开启正负号。         和  类似，但是输出数字时总是使用科学计数法。  除此以外，还有英语指令，生成带有正确复数化单词的消息。使用  即可，如果对应的参数大于 1 ，输出一个 ，所以，类似这样的 Python 代码：    可以是：    可以开启  和 ，让它重新处理前一个格式化参数，以及自动添加单词的复数：    对于大小写，可以使用  处理，它接收 ， 开关：    以及更加复杂的条件格式化，迭代格式化和跳跃格式化。还能够生成表格。<del>希望不要用到它们</del>  文件  和很多其他编程语言一样，CommonLisp 也用「流」来表示输入和输出。而想  和  这样的函数，其作用对象也是一个流。读取和写入文件，需要几个函数： ， 等。   制造出合法的文件路径名称，它只接收关键词参数，有六个：、、、、 及 ，返回一个路径名称：    接下来是打开文件，使用  函数。这个函数很复杂，它接受一个路径名和大量关键字参数，开启成功时返回指向文件的流。常见的关键词参数有 ，决定是写入流还是读取流，选项有 ，，，还能够指定文件存在时是否覆盖，使用  参数，使用  覆盖。打开以后，你就可以使用  等函数写入读取了。在最后要记得使用  关闭流。举例：    就像 Python 有上下文管理器，使得你可以写出  一样， CommonLisp 也有一个宏帮助你管理流，使用  可以管理，用它重写上面的例子：    读取示例：    参考  -  -  -", "url": "/articles/CommonLisp基础-常见操作.html"}, {"title": "CommonLisp基础-分支和循环", "content": "uuid: \"41a43b0c-279b-438f-9ee6-dbe98965ce46\" title: CommonLisp基础-分支和循环 date: 2023-01-19 category: 学习   分支  , , 和    的作用和效果和一般常识一致，其形式为 ，使用    组合判断：    但是， 只能执行一个表达式，所以如果需要组合执行很多任务，需要使用  代码块：    这个逻辑可以使用  宏重写：     是  的反过来版本。两者是建立在  上的宏。而  是特殊操作符。    类似于 C 中的  但是没有  也不限制 int 类型：    循环   的循环可以很复杂，所有的循环操作宏都建立在底层的  之上。   和   -  类似  这样：        -  则类似  这样：              最基本的迭代操作符是 ，它可以同时迭代多个值，其基本形式如下：    这个  有些晦涩难懂，第一个  是一个列表，内容是 ， 与  形式是选择性的。若  形式忽略时，每次迭代时不会更新变量。若  形式也忽略时，变量会使用  来初始化。,例如：    这就定义了三个变量。接下来是  中止条件，它也许要被括号括起来，因此，一个类似这样的 c 代码：    可以写成：    记住 do 需要三个部分即可，哪怕其中没有需要操作的表达式：    简单来一个鸡兔同笼：    再举一例，计算斐波纳契数列：      很少有人能够真的搞懂  的全部，这玩意是属于「高阶魔法」，比如，  可以写成这样的形式：     提供了诸如「、  、  、  、  、  、  、  、  、 」这样的关键字，实际上是一个专门用来写循环迭代的新的语言。  > 如果你是曾经计划某天要理解 loop 怎么工作的许多 Lisp 程序员之一，有一些好消息与坏消息。好消息是你并不孤单：几乎没有人理解它。坏消息是你永远不会理解它，因为 ANSI 标准实际上并没有给出它行为的正式规范。  > 这个宏唯一的实际定义是它的实现方式，而唯一可以理解它（如果有人可以理解的话）的方法是通过实例。ANSI 标准讨论 loop 的章节大部分由例子组成[^sn1]  最基础的  句法是  句法，示例：  - 遍历一个列表：        - 遍历多个范围：      - 控制起始和更新形式：        - 各种谓词：      - 列表的过滤：      - 解构：      - 条件执行：      学  要多用它（  [^sn1]:   这段评价的来源是 《ANSI Common Lisp 中文版》 第十四章：进阶议题", "url": "/articles/CommonLisp基础-分支和循环.html"}, {"title": "CommonLisp基础-基本概念", "content": "uuid: \"f7127a84-86a8-41dc-8fdc-893cd1118438\" title: CommonLisp基础-基本概念 date: 2023-01-18 category: 学习   本文整理作为一门编程语言的 CommonLisp 的基本元素，以便「能够用它写出程序来」。  历史  和他的学生于 1958 年展开 Lisp 的初次实现工作。 Lisp 是继 FORTRAN 之后，仍在使用的最古老的程序语言。 Lisp 是计算机科学领域的「经典语言」之一，完全是一门现代通用语言,其设计反映了尽可能高效和可靠地求解实际问题的实用主义观点。  概念  Lisp 是一门交互式语言。有一个叫做「顶层」的环境运行 Lisp 代码。  所有的 Lisp 代码都是「S-表达式」，但并不是所有的 S-表达式都是合法的 Lisp 代码。宏给了语言的用户一种扩展其语法的方式，把任意的 S-表达式转换成合法的 Lisp 代码。  使用  可以防止表达式被求值。例如：    基本类型  真和假  符号  是唯一的假值,其他所有的都是真值，符号  是标准的真值。  测试相等性有四种方法：  - ：测试「对象标识」，两个对象是同一个东西时才等价。移植性差，避免使用。  - ：类似 ， 保证当相同类型的两个对象代表相同的数字或字符值的时候是等价的。所以  确保是真的。  -  ：将具有递归相同结构和内容的列表视为等价。 为 ，而  为 。  - ：更加宽松的相等。  测试：    |          | a=1,b=1 | a=1,b=1.0 | a=\"hi\",b=\"hi\" | a='(),b='() | |  |  |  |  |  | |      | T       | NIL       | NIL           | T           | |     | T       | NIL       | NIL           | T           | |   | T       | NIL       | T             | T           | |  | T       | T         | T             | T           |  数字  CommonLisp 支持整数，浮点数，复数等。  !  - 整数：      可以使用常规的写法，也可以使用任意进制写法：      常规写法：，，，      任意进制写法：二进制：，八进制：，使用  以 2 到 36 的其他进制书写有理数  - 浮点数：      同样可以使用多种写法：，，，，  四则运算的截断和舍入：  1. ：向正无穷截断，返回大于或等于参数的最小整数。  2. ：向零截断。  3. ：舍入到最接近的整数上。如果参数刚好位于两个整数之间它舍入到最接近的偶数上。  4. ：向负无穷方向截断，返回小于或等于参数的最大整数。  模和余数：  - 模：  - 余数：  变量的增减：，  其他：，，（检测偶数），（检测奇数）  数字的比较使用   字符串  字符  字符和数字是不同类型的对象，字符的表示：，例如字符 ：，字符：（）,特定字符的替代语法是 #\\ 后跟该字符的名字。例如   字符不是数字，不能使用数值比较函数。使用 。它接受任一数量的参数并 只在它们全是相同字符时返回真，相应的还有 ，，，等对应 ，等。  字符串  字符串是字符的一维数组，字面字符串写在闭合的双引号里，使用斜杠来转引  和  符号。字符串的比较使用  系列函数，简单地来讲就是把字符比较系列中的  替换为 。    函数类型  把函数的名字传给 function ，它会返回相关联的对象，用  作为 function 的缩写。  使用  定义匿名函数：   函数：  集合类型  列表和向量的区别应该可以类比为 C++ 中标准库容器和 C array 的区别(？)  列表（list）  列表使用括号直接创建：，也可以使用  来创建。列表是序列的子类型。列表是最常见的数据结构，可以用来模拟树，下推栈等数据结构。  列表的基本元素是 Cons，一个 Cons 可以看作是由一个保存元素的单元和指向下一个元素的指针，  最初是动词 construct 的简称，除非第二个值是 NIL 或是另一个点对单元,否则一个点对将被打印两个值在括号中用一个点所分隔的形式，前面一个元素叫做 ，后面一个元素叫做 。所以，一个包含 1，2 的列表类似于：    它事实上是  ，简单写作 。  取出列表元素的基本函数是 car/first 和 cdr/rest 。对列表取 car 返回第一个元素，而对列表取 cdr 返回第一个元素之后的所有元素，你可以使用 setf 来设置一个 cons 单元的 car 或者 cdr：    常用函数：  - ：翻转列表： ->  -  到 ：获得某个元素。 - ：接受两个参数,一个索引和一个列表,并返回列表中第 n 个(从 0 开始)元素 - 复合  函数：例如：   参见：  副作用和「破坏性操作」：  纯粹的「函数」是说函数完全基于其参数的值来计算结果，比如  是完全「函数式」的。修改已有对象的操作被称作是破坏性的，原来的那个对象的状态改变来了。  排序和映射  - 排序使用  和     两者会破坏序列。参数是序列和谓词函数。例如：，对一个序列排序并赋值一般使用  的形式。   可以使用关键词参数  来指定复杂数据结构中用来排序的元素。  - 映射    映射是对高阶函数的使用。有六个用于列表的 map 函数，最常用的是这两个：    1. ：   2. ：将列表的渐进的下一个 cdr 传入函数。              ->         树  Cons 对象可以想成是二叉树， car 代表左子树，而 cdr 代表右子树，Common Lisp 有几个内置的操作树的函数。copy-tree 接受一个树，并返回一份副本。  集合  CommonLisp 的列表可以看作是一个集合，使用一系列函数来把列表作为集合操作：  - ：向一个集合添加元素。 -  和 ：测试是否在集合中 -  、  、及 ：集合论相关操作（交集，并集，异或）。  栈   把 x 放入列表 y 的前端。而  则是将列表 x 的第一个元素移除，并返回这个元素。  变量和常量  使用  来引入局部变量   的一般形式是：    局部变量不会「污染」外部的变量，它们只在特定的上下文里有效，嵌套绑定同名变量，那么最内层的变量绑定将覆盖外层的绑定，所有的绑定形式都将引入词法作用域变量。  使用  和  来引入全局变量  命名约定：全局变量使用信号「*」包围起来。，例如 。参数：变量名，初始值和文档字符串。其中文档字符串可选。 总是将初始值赋给命名的变量,而  只有当变量未定义时才这样做。    使用  来引入全局常量  和  类似：，一些常量是预先定义的，例如 π 的值：。  使用  来赋值  可以用来给全局或局部变量赋值，类似其他语言的 。    注释  注释使用  来开头。  ;;;; 四个分号用于文件头注释。  ;;; 一个带有三个分号的注释将通常作为段落注释应用到接下来的 ;;; 一大段代码上。  ;; 两个分号说明该注释应用于接下来的代码上。  ; 一个分号仅用于本行  另外可以使用「文档字符串」功能。  函数  所有 Lisp 程序的三个最基本组成部分是函数、变量和宏。要定义一个函数，使用 。 是一个宏。    参数  必要形参    必要形式参数和预期的一样工作，按照传入的次序绑定。不能多也不能少。      可选形参    可选形参为调用者提供了一个默认的值，而关系它们的人可以提供一个指定的值。定义方法是在必要参数的名字之后放置符号&optional，后接可选形参的名字。默认的缺省值为 ，将形参名替换成一个含有名字跟一个表达式的列表来指定该缺省值。        可选形参表达式可以绑定第三个参数，用来判断这个参数是用户提供的还是默认的，例如  中的  将会在用户指定值时为 ，否则为 。  剩余形参    在符号  之后包括一个一揽子形参。如果一个函数带有一个  形参,任何满足了必要和可选形参之后的其余所有参数将被收集到一个列表里成为该  形参。      关键字形参    在任何必要的  和  形参之后可以加上符号  以及任意数量的关键字形参标识符。      参数声明的顺序是：首先是必要形参,其次是可选形参,再次是剩余形参,最后是关键字形参。  正常情况下，函数的最后一行会作为返回值返回，如果需要在控制流程中返回，使用 。", "url": "/articles/CommonLisp基础-基本概念.html"}, {"title": "Python协程的使用", "content": "uuid: \"4798069b-f6d7-48df-ab8c-a64c0da7739d\" title: Python协程的使用 date: 2023-01-09 category: 学习   「协程」看它的名字不是个很好理解的词语，其英文 Coroutine 的定义是「Computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed.」它与普通的子例程的区别在于「allowing execution to be suspended and resumed」，通俗的来讲，就是一个「可以暂停和恢复的，同时能够保存一些信息的子例程」。在 Python 中，，，， 关键字都能够用来做协程处理。  基本行为  一个协程基本上是一个特殊的函数，不过与普通的函数不同，协程可以保存内部的状态，将控制流程转移出去，同时在运行时接收外界进一步的信息。假如有函数 ， 和协程 ，那么控制流程可以是这样的：    举例来说明:    在这个简单的例子中， 只是按照次序返回 1，2，3。其实，a 的类型是一个 ，也就是生成器类型。使用其  方法，或者调用  可以获得一个值，同时协程返还控制权，直到所以值被消耗完毕，抛出  异常为止。  协程和普通函数最大的区别在于其不使用  而是使用 ，说句老实话，我觉得「协程」这个词倒不如换成「yield 函数」之类的说法，<del>当然语言律师和专家们可能会大皱眉头。</del>  传出数据  最简单的方法就是用  来传出数据。    由于是一个 Generator，可以直接在循环内使用它，可以看到，协程函数保存了 number 变量，在重入时依旧使用它。当然，这么简单的任务直接使用列表生成式即可： 得到的也是一个 。  接收数据  要发挥协程的作用，需要让协程能够「获取」数据，也就是在每次交换控制权的时候给协程发送数据。对于一个协程，使用  可以向它发送数据，并交换控制权。在第一次发送数据之前，需要预先激活它，即使用  来预激。  举例[^example] 来讲：    得到的结果是：    各个阶段都在 yield 表达式中结束，而且下一个阶段都从那一行代码开始,然后再把 yield 表达式的值赋给变量。图示如下：  !  再举一个不一样的例子，经典的「计算斐波纳契数列」：    再来一个经典版本：      相比之下协程版本只需要 0.012 秒。  只用来控制流程  如果  前后都没有东西，那就仅仅是用来切换控制流程，比如一个计数器：    yield from   可以说是一个比较难懂的玩意。简单的来讲，这个  的作用就是「再一个协程中获取其他协程的内容，并统一发送回来」。  例如，打平一个嵌套的列表：    当然，更好的实现是例如 more-itertools 模块中的  或者  中的 flatten 函数  自动初始化  每一次运行协程之前，需要手动  来预先激活它达到第一次 yield 的位置，否则你就会遇到    这一步当然可以自动化。比如，可以写一个专门创建的函数包装它：    更好的方法是使用装饰器：    那么对于需要作为协程的函数，添加一个  装饰器即可。  应用  分发器  对于一个数据来源，把它「分发」给不同的消费者：    得到的结果是：  !  [^example]:   这个例子的来源是「流畅的 Python」一书，书中举的例子是「使用协程计算移动平均值」。", "url": "/articles/Python协程的使用.html"}, {"title": "Portacle的使用", "content": "uuid: \"9886aba7-4b9c-4070-9ce3-1e30734b757b\" title: Portacle的使用 date: 2023-01-06 category: 备忘录   Portacle 是一个 CommonLisp 运行时和开发环境，没有复杂的安装流程，更没有附带各种恶心限制的许可证(<del>说的就是你 LispWorks</del>)，使用方便。基于 Emacs 构建，自带 SBCL，busybox，Quicklisp，git，SLIME。  安装配置  在下载 tar.xz 包，然后解压到希望安装的目录下。运行即可。加载配置文件需要一小会儿，之后就能看见主界面了。  第一次运行需要先进行用户配置，按  输入  回车，按照提示进行初次配置。  !  主界面默认上下分栏，上面的是  区域，用来编辑运行环境里面的 Lisp 代码，下面的是 ，用来和 Lisp 解释器交互。Portacle 有一个现代 IDE 应该有的功能，包括自动补全，文档提示，自动格式化代码，错误提示等等。  基本操作  由于 Portacle 是基于 Emacs 的，所以掌握 Emacs 的基本操作也就是掌握 Portacle 的基本操作。  Emacs 相关  按照一般的写法， 就写成 ， 就写成 。在标准键盘上，Meta 键就是  键。  如果你键入一半的快捷键不想操作了，狠狠的摁几下  即可。  光标操作  | 键位  |            操作             | | :: | :: | |  |        光标向上移动         | |  |        光标向下移动         | |  |        光标向左移动         | |  |        光标向右移动         | |  |        向前跳一个字         | |  |        向后跳一个字         | |  |         到一行开头          | |  |         到一行结尾          | |  | 到段落开头(函数/宏定义开头) | |  | 到段落结尾(函数/宏定义结尾) | |  |          向下一页           | |  |          向上一页           |  撤销重做  |  键位   |      操作      | | :: | :: | |  | 撤销上一个行为 |  删除  被按行/句为单位删除的会被保留在剪切环中，之后可以取回来。  |     键位      |      操作      | | :: | :: | |          |   删除一个字   | |  | 向后删除一个词 | |          | 向前删除一个词 | |          |   删除到行尾   | |          |   删除到句点   |  复制粘贴  - 对于删除掉的保存在剪贴环中的内容，使用  取得。  - 使用以下操作进行任意选区的复制粘贴：      1.  进入  模式；      2. 移动光标选取需要的内容；      3.  复制到剪贴环；      4.  粘贴。            也可以直接使用鼠标选取区域。  在 buff 之间切换  可以把 buff 理解成是标签页，一个 Emacs 可以打开很多 buff，你需要在不同的 buff 之间辗转挪移。  !  |          键位           |                         操作                         | | :: | :: | |             |                   创建一个空 buff                    | |         | 上一个/下一个 buff，left 和 right 就是小键盘的方向键 | |                |                    列出所有 buff                     | |                |               设置这个 buff 的只读状态               | |                  |                      关闭 buff                       | |  |                交互式的一个个提示关闭                |  文件操作  你在 scratch 里面的文件虽然加载到了 Lisp 环境里面，但并没有保存！  |   键位    |           操作           | | :: | :: | |  |       打开一个文件       | |  |       保存文件       | |    | 在光标处插入指定文件内容 | |    |         全部保存         |  另外，如果你要直接载入 Lisp 代码，需要在 Slime 里面执行：   来载入代码。  另一种加载文件的方法是，先用 COMPILE-FILE 编译，然后再用 LOAD 加载编译后产生 的文件,也就是 FASL 文件。前者将返回 FASL 文件的名字,所以可以在 REPL 进行编译加载:    最后，在一个源代码缓冲区的时候,可以使用  调用命令  来加载文件。Emacs 将会提示你给出要加载的文件名,同时将当前的文件名作为默认值，直接回车就可以了。  搜索和替换  |    键位     |        操作        | | :: | :: | |        |    光标向上移动    | |        |      向前搜索      | |        |      向后搜索      | |    | 回到搜索执行的地方 | |  |     交互式替换     |  SLIME 相关  默认下面的 buff 就是 slime 的 repl，你可以在这里执行 lisp 。注意，这个 lisp 不是 Emacs 内置的 EmacsLisp，而是 CommonLisp！  repl 中使用   来编辑历史命令！  slime-selector  这个 slime-selector 可以快捷的在各个不同的 slime buff 之间跳转，相当于是给各个 buff 定义了快捷键。默认情况不绑定，需要手动绑定以下。  打开按照目录的  在最后加上按键绑定  之后重启即可，之后就可以使用  来快捷到达某个 buff。  常见的选项：  - ?     查看帮助  - r     进入 SLIME 的 repl buff，也就是默认界面下面的 buff  - d     最近一次激活的 debugger buff  - l     最近一次访问的 lisp-mode 源码 buff.  - s     slime-scratch buffer，也就是默认界面上面的那个 buff  所以，在任何时候想要去 repl 只要  即可。  执行  |   键位    |      操作      | | :: | :: | |  | 执行上一个语句 |  编译  |   键位    |                操作                | | :: | :: | |  | 编译函数，被编译的对象会被高亮显示 | |  |              加载文件              | |  |           加载并编译文件           |  寻找定义  |   键位    |             操作             | | :: | :: | |      | 跳转到目前光标所在位置的定义 | |      |       返回寻找时的位置       | |  |   打开新的窗口编辑目标定义   |  获取文档  !  |    键位     |       操作       | | :: | :: | |  | 描述光标处的定义 | |  |  slime-apropos   |  错误处理  !  有时候你的 Lisp 代码出错了，Slime 会打开一个临时 buff 来处理出错，你可以直接按  关闭这个 buff。  其他问题  中文字体似乎很是难看，我尝试了这样配置：    但是无效:-(  !  参见  -  -  -", "url": "/articles/Portacle的使用.html"}, {"title": "雨课堂考试系统分析", "content": "uuid: \"4ca67c26-00b4-4c79-bbac-65f9a7a434b5\" title: 雨课堂考试系统分析 date: 2023-01-04 category: 技术   最近需要用到雨课堂来在线考试，向来讨厌这种考试方式，又听说它有截屏，切屏上报等等功能，正好有认识的老师愿意把他的帐号借给我，就简单分析了一下。  简介  雨课堂的网页端考试系统用的是 Vue 用到的框架/库有 Element UI, Sentry, MathJax, core-js, Clipboard.js ，存储采用自己 cdn + 阿里云 + 七牛云的混合存储，前端文件用 Webpack + Babel 打包，所有接口 API 地址都暴露在全局空间  中。判断浏览器环境采用 UA 字符串匹配，可以用虚假 UA 绕过，但会导致出现问题。每隔 3 分钟自动截取屏幕和摄像头上传。  各个功能分析  获取试卷内容  没有花里胡哨的加密，很朴实的获得试卷内容，并逐个放到 vuex store 里面，接着渲染。接口明确给出的，就是  ，你甚至可以重放 xhr (  当然，获取试卷内容需要一个名为  的 cookie，是一个 HS256 JWT Token，内容形式是    获取时只校验 token，不管 UA。这个 Token 在进入考试时获取，甚至没有设置 HttpOnly。  时间同步  每隔一段事件会和服务器同步数据，使用 setintervel + xhr 方式，防止通过修改本地事件作弊。  反调试  在整个 HTML 文档的开头，有检测是否有禁用切屏的代码，被 eval 混淆了。  !  搞笑的是，雨课堂的前端似乎真的只是在网上「在线混淆工具」就拿来用了，解密之：    可以看到这个函数的作用是把「sessionStorage.setItem」包装了一层，添加了一个新的「setItemEvent」事件。用来检查和反馈「检测到你已禁用切屏监测功能，该行为已记录并上报老师，请立即停止异常行为！」了。虽然十分的奇怪（  检测打开调试工具  如果学生打开控制台，会提示「检测到你已禁用切屏监测功能，该行为已记录并上报老师，请立即停止异常行为！」，这个提示只在  的时候显示一次，之后不再重复显示。  检测的方法没有仔细探究，但注意到它覆盖了原来的 console.log 方法并包装了一层，以前看到过类似的检测思路，但似乎并不是的方法。  !  切屏检测  使用的是非常常见的方法，即  的方法。直接搜索就可以找到源码位置，打断点，看 call stack 保存一份引用，就能把 callback 去掉了。直接 。  !  !  另外，也可以直接拦截 addEventListener 的调用，很简单就能够阻止 callback 的绑定。    自动截屏  雨课堂考试的监考，并不是实时传输屏幕的数据，而是每隔一段时间（一般是 3 分钟）截取一张样本上传，同时设置 sessionStorage 的  项目保存时间戳。上传的目标服务器是根据地区选择的，都是七牛云的服务器。    数据上报  数据上报分两种，一种是常规数据的上报，也就是本地事件同步和间隔截屏的数据。第二种是检测到切屏，打开调试工具后的事件上报，通常还会顺便提交截屏作为「证据」。  第一种上报，就是 setintervel，使用了，retryCount 设置是 3 ，也就是最多尝试上传 3 次。整个流程先在雨课堂的 API 获取 token，再上传。  !  第二种是对于考试事件的检测和上报，和以前的版本不同，现在雨课堂不再使用单独的 API 地址来上报，而是使用和提交答案一样的 API，上报的内容依旧是 json 文本，格式如下：    其中  即为事件的编号。切出当前页面是 12，切回则是 16。更新答案选择（即自动保存答案）使用同一个 API，但数据格式不同。  令人啧啧称奇的是，这个汇报情况的 API 没有速率限制，你可以用一个简单的脚本把自己的切屏次数刷到很离谱的数量。  水印  水印通过 CSS 背景图片实现，选择器为 ，base64 编码 png 格式。  绕过思路  如果你想硬核绕过，不是很难  - 对于切屏检测，直接把监听器移除。 - 对于文件上传，老方法，屏蔽七牛云的服务器即可。但是这样一来，一开始上传证件照会失效。 - 对于事件上传，大条的方法是用 uBlock 之类的工具屏蔽特定 xhr 请求，但是会影响自动答案保存。 - 如果你想要硬核的，proxy 劫持整个 XHR 对象原型，但是注意雨课堂已经用  包装了一层。 - 对于水印，CSS 覆盖就完事了。 - 摄像头，可以使用 Chrome 的虚拟摄像头功能。  但是，如果你真的要和它对着干，不建议和它在同一个层次作战。更加稳妥的方法是使用虚拟机。   参考  -  -  -  -", "url": "/articles/雨课堂考试系统分析.html"}, {"title": "Chrome文件伪装摄像头", "content": "uuid: \"6f21a5a7-d7da-48e5-8afc-54d5644d73bf\" title: Chrome文件伪装摄像头 date: 2022-12-31 category: 备忘录   有时候需要用到伪装摄像头的功能，特别是使用某些网课平台考试的时候，有的建议是使用 OBS Studio 模拟一个摄像头，但是其实 Chrome 浏览器就可以把文件作为摄像头的视频来源采集。  文件准备  首先你需要有视频或者图片文件，但一般的 mp4, mkv 之类的格式是不行的。关于 Chrome 支持什么格式，手册页里面没有说明，但是源代码里面有：    要作为流的来源你需要 y4m 或者 mjpeg 格式的视频。使用 ffmpeg 可以转换。    开启选项  接下来你需要使用命令行参数启动 Chrome 浏览器，加上你的文件：    检测和注意事项  - y4m 格式是很大的，一分钟不到的视频都可能达到 700 MB。 - 可以使用来测试。 - 网页检测到的「摄像头硬件名称」将会是你的文件名，注意起一个正常的名字。  参考  1.", "url": "/articles/Chrome文件伪装摄像头.html"}, {"title": "Firefox启动速度缓慢的排查", "content": "uuid: \"1e64ae1f-5c22-43eb-a3f1-6a5a0162052b\" title: Firefox启动速度缓慢的排查 date: 2022-12-26 category: 杂项   TL；DR：直接在  里增加一行记录，把本机主机名指向  即可。  一般 Linux 发行版的默认浏览器都是 Firefox, 但是我在 openSUSE 上的 Firefox 启动每一次都需要很久，而且每次等待的时间还不一样，多则 10 秒，少则 3-4 秒，很是折磨人。这个问题之前用其他发行版的时候都遇到过，可以确定不是操作系统的原因，我不想因为这个原因就放弃 Firefox 使用 Chrome，所以打算彻底调查一下问题的原因。  首先我尝试着使用安全模式打开 Firefox, 在命令行启动时加上 , 但是依旧没有效果，所以可以排除是扩展插件的问题。我遂怀疑是 Firefox 在寻找某个文件的时候出了故障，用  追踪一下系统调用，加上时间戳，找到间隔好几秒的断层，看看它到底在访问什么文件：     是加上时间戳， 输出为文件， 增加过滤器。  结果发现了这个：  !  Firefox 在尝试访问  这个文件。但是系统调用是成功的，而且我查看文件内容也没有毛病。这个文件本身是本机 DNS 解析的配置文件，Firefox 访问它想必和 DNS 解析有些关系。那么我想用可能是因为 Firefox 试图访问一个被墙了的网站，超时导致延迟。那么就要捕获所有的 DNS 解析尝试，我想到了使用 .  虽然  是一个代理工具，但是它会在控制台显示被代理的程序的互联网访问记录，我尝试了一下，可是一无所获。  上网搜索了一下，发现有一位仁兄在 8 年前于 Bugzilla 上提了一个差不多的问题，标号是 . 他的分析是，Firefox 启动时会对本机进行一次 DNS 查询，导致超时。所以按照这个思路，我只需要过滤出所有的网络相关系统调用，看看有没有我自己的主机名即可：    自己的主机名称在 ，过滤可以看到：  !  果然。  那么，只要让 DNS 访问直接指向本机即可，解决方案很简单，直接在  里增加一行记录，把本机主机名指向  即可。再次尝试打开 Firefox, 启动速度稳定保持在 2 秒左右。  现在想起来，应该是自己自定义主机名时，把原来主机名后面的  去掉了，导致 DNS 解析不出来。", "url": "/articles/Firefox启动速度缓慢的排查.html"}, {"title": "ELF文件结构解析", "content": "uuid: \"5b68c30c-b953-4bee-a7e9-51aa7f2a30e8\" title: ELF文件结构解析 date: 2022-12-25 category: 学习   > 「所谓文件就是一大袋子字节，而它的含义则取决于程序怎么解释它。」  ELF 文件  ELF 的全称是「Executable and Linkable Format」。是最常见的可执行文件格式。其源自于 SystemV UNIX R3 版本的 COFF 格式，后来微软基于 COFF 发展了 PE 格式，SystemV UNIX R4 基于 COFF 发展了 ELF 格式。  ELF 文件也就是一个普通的文件。它包含一个文件头和若干个段。段的数量是任意的，头只能用一个。每个段都有一个字符串名称，一般以「.」开头的段名称，诸如 ,  等是编辑器保留的名称。所有的段名对于操作系统来讲没有意义，只有这些段的属性，诸如「可执行」，「只读」等有意义。  要解析 ELF 格式，其目标实际上就是精确的得到各个段的位置和它们的名字。  读取和解析 ELF 文件  读取 ELF 文件需要获得几个重要的结构，此处以 x86-64 系统为例，需要获取的分别是 ELF 文件头，保存该文件所以段的信息（不是段本身的内容）的数组，以及保存段表字符串表的字符数组。其中：  - ELF 文件头。      结构名称为 。每一个 ELF 文件只有一个。保存了关于这个文件的属性信息，和用来定位段表位置的  和用来获取段表字符串表在段表中的下标的 。        读取方式可以是：      - 段表。      段表是一个  构成的数组。每一个元素保存了这个段在文件中的偏移，以及这个段的属性。其中  是用来定位这个段的名字在段表字符串表中的下标。这个段表的偏移在文件头中，大小可以用「每段长度 * 段的数量」确定。两者都在文件头中给出。            获取整个段表可以是：            注意：段表的第一项所有项目都是 NULL 。  - 段表字符串表      段表字符串表是保存所有段的名称字符串的单独段，假设一个 ELF 文件有 ，， 三个段（不包括段表和段表字符串表），那么段表字符串表的内容可以是：      !      那么， 在段表中的数据中  的指向就是 2 ，即等宽的那一项。它的段名一直到最近的 「\\0」。      要获取段表字符串表，直接在段表中找到对应下标的项目即可。这个下标也就是文件头中的 。  使用 readelf 工具  可以直接使用  工具打印出 ELF 文件的信息。一般使用  参数，打印出所有段的信息，起始位置等等。", "url": "/articles/ELF文件结构解析.html"}, {"title": "Rclone挂载Office365教育版", "content": "uuid: \"e2e757b5-b9d8-4613-92b4-1bdd12738583\" title: Rclone挂载Office365教育版 date: 2022-12-20 category: 备忘录   有时候我还是很羡慕 Windows 用户能在他们的资源管理器里面直接和 OneDrive 交互，我想要在 Linux 上也实现这样的功能。恰好我有 OneDrive 帐号，结合 rclone 即可。  非教育版帐号  很简单。安装 rclone 之后，运行  ，按照向导一步步创建配置即可。建议给配置取的名字不要有空格和非英文符号。在创建完毕以后，使用  测试即可。 注意配置名称后面的那个冒号不要漏掉。  至于集成在系统里面很简单。可以直接挂载成 FUSE 文件系统给各个程序无缝使用：    但是如果网络不稳定那就会带来很多奇怪问题，所以参考使用 Webdav 方法挂载：    让 rclone 作为 WebDav 服务器运行。如果你使用 KDE 的话，在 Dolphin 中添加一个远程即可：  !  然后你就可以在右侧的 Remote 中找到 OneDrive 了。第一次点开可能需要你输入用户名和密码，这个用户名和密码是 rclone webdav 服务器的，不是你的微软帐号。   如下图，上面的教育版，下面的是个人帐号。  !  教育版  很遗憾，教育版本不能使用这个方法登录。如果你尝试在浏览器验证，那么会得到  的消息。 如果要接管你的教育版 OneDrive，需要得到域管理员的同意。除非你能够说服学校负责人，否则不能连接第三方应用。所以必须使用其他方法。  Office365 有个功能叫 SharePoint，而这个玩意可以作为 WebDav 操作。对微软复杂的产品我不很了解，但这个 WebDav 是可以直接用 rclone 挂载的。  1. 首先，你需要网页版进入你的 OneDrive，网址应该是以  这样的模式开头。  2. 在 OneDrive 的根目录创建一个  目录，当然其他名称也可以。  3. 按照这个模式拼接出 SharePoint 地址：            其实也就是直接复制网址，把后面的多余部分清除，再加上 Documents。账户名称里面的下划线不要改动。  4. 创建 rclone 配置，选择类型是 WebDAV，输入第四步创建的 URL，再选择  作为 vendor，接着输入你的账户名和密码，也就是你用来登录网页版 OneDrive 的账户名(你的学校邮箱)和密码。  最后的结果应该是这样的：    接下来使用  测试即可。挂载集成和之前一样，开一个 rclone 的 WebDav 再转手一次。  注意事项  1. 虽然配置的 url 是 Documents，但是实际挂载的就是整个网盘，url 路径和挂载无关，但必须要有一个，不能是根目录。 2. 如果你的 OneDrive 网页版还登录着，那么 Dolphin 中挂载的 SharePoint 就是只读的，必须把其他 session 全部退出再重新挂载才能读写。 3. 如果你碰到了  这样的问题，就是你的账户名和密码不对，检测一遍。username 就是你的邮箱，不是 「Domain\\User」 的格式，也不要把点号替换成 url 里面的下划线。  sftp公钥登录  Dolphin 支持的远程协议很多，包括 sftp，如果你有个服务器的话挂载在本地似乎也不错。直接在 Dolphin 新建，输入  创建配置。  但是，如果你的服务器是公钥登录，就会失败， Dolphin 不会让你输入公钥。你需要修改 ，添加条目来做到自动连接。格式如下：    然后就能正常连接了。  参见：  -", "url": "/articles/Rclone挂载Office365教育版.html"}, {"title": "scrcpy+sndcpy+kdeconnect多屏协作", "content": "uuid: \"92a3c86b-baca-4a5d-bf87-e4b091adfd74\" title: scrcpy+sndcpy+kdeconnect多屏协作 date: 2022-12-19 category: 备忘录   「多屏协作」是很多电子设备厂商的卖点，本着  的头铁原则，使用 Linux 也可以利用各种工具实现这样的功能，并且，效果还不错。  目标  要达到我心目中的「多屏协作」，至少需要：  - 手机屏幕投射 - 双向文件互传 - 剪贴板分享 - 双向远程控制 - 媒体转接 - 通知传递  另外这一切都不应该借助数据线，经过一番折腾，我基本实现了这些目标，虽然免不了有一种自由软件大杂烩以后经典的「它能跑，但是毛毛糙糙」的感觉。  scrcpy  是一个命令行应用，用于把安卓设备的屏幕投射到电脑上，支持交互功能。你可以在下载。除此以外，你还需要在电脑上安装 adb 调试工具链接电脑，并在手机上打开 USB 调试功能。  最简单的使用就是直接用 USB 链接手机，允许 USB 调试，之后终端执行    即可。scrcpy 自带了键盘模拟输入，鼠标代替触摸操作等。除此以外，系统剪贴板和手机剪贴板可以自动互通，拖放电脑文件到手机窗口会把文件 push 到  目录，也就是手机默认的「下载」目录。  手机关闭显示  如果你觉得手机一直亮着很费电，添加  参数在连接电脑后自动熄灭屏幕即可。当然，如果再次操作物理手机还是能够正常使用的。  多个设备连接  如果你有很多设备连接，要么指定设备序列号，要么使用无线调试。先使用  列出所有设备，第一列的就是设备编号，scrcpy 使用  参数来辨别你要连接的设备。    无线调试  在同一个局域网下，可以使用无线调试功能，解放 usb 插口。  :::{.note .blue} |     | |  | | 💭 无线调试比较费带宽，如果 wifi 信号不好，或者正在下载什么东西，可能会卡顿明显。 | :::  首先，你需要 USB 连接手机，确保 adb 畅通，接下来，启用无线调试：    默认的端口是 5555，当然你也可以自定义。接下来你要知道你的手机的 IP 地址：    和 PC 不同，Android 设备会密密麻麻显示出几十个网络接口，一般 wlan 接口就是  之类的，局域网地址一般以  开头。找到以后，输入 connect 连接：    如果没有问题，会显示 ，这时候再  会显示出无线调试的设备。此时就可以拔出 USB 线，直接远程连接了。如上所述，远程连接会比较耗费带宽，如果卡顿，可以试试限制视频大小。使用  参数限制视频的宽度和高度，长宽比会被保留。实际上 1024 就可以用了，除非是列文虎克，否则看不太出来差别。    如果出现问题或者找不到设备：  1. 再三检查自己的手机有没有连接 wifi，并且和电脑在同一个网域。 2. 尝试  重新来过。   连接结束后，可以使用  结束连接。  录屏  使用  参数加文件名录屏。格式是 mp4 或者 mkv，按照文件扩展名自动选择。    实际测试一段 8 秒钟的视频，使用 mp4 格式，  参数，大小是 4MB 左右（无声音）。  :::{.note .red} |     | |  | | ⚠️ scrcpy 很诚实，它会把所有的一切录下来，包括你的锁屏和锁屏密码！ | :::  注：Android 13 以后不再有这个问题。  多重虚拟屏幕  Android 开发人员选项有一个 Simulate secondary displays 的选项，可以设置虚拟显示屏。如果你的手机支持「桌面模式」，可以尝试开启，在手机和电脑上各开一个显示。  你可以使用 adb 命令开启一个虚拟显示输出：    然后通过    来获取虚拟显示输出的编号。编号 0 是手机的物理屏幕。接下来就可以使用 scrcpy 连接指定的虚拟屏幕了：    注意，不是每一个型号的手机都可以支持「桌面模式」，大部分手机的虚拟显示器投屏以后只是灰屏。  如果你想关闭虚拟显示屏，在「开发人员选项」里面找到 Simulate secondary displays 选取一个再关闭即可。  sndcpy   只能投送屏幕，不能接管音频。如果想要把手机的音频也接管到电脑上来，需要其他的工具。你可以在下载。要运行这个工具，你需要：  1. Android 10 或者以上的操作系统 2. 你的 PC 上安装了 VLC 并且在 path 里面 3. 你可以 adb 连接你的手机  解压 release 的压缩包以后，是运行脚本和一个 apk。主要就是依靠这个 apk 来完成音频转发。使用方法：    运行以后有可能会有报错，无妨，稍等即可。尝试表明，音乐应用等的音频可以转发，但是腾讯会议的音频在目前版本 (v1.1) 无法转发。  kdeconnect  在 KDE 上使用 KDE Connect 和手机进行消息通知同步等可以使得你的「多屏协作」体验更好。使用 KDE Connect 需要：  1. 你的手机和电脑在同一个网络下 2. 你的手机安装 KDE Connect 3. 防火墙放行相关端口  并不是只有 KDE 才能使用 KDE Connect，Gnome 乃至 Windows 平台都可以享受它。在 Gnome 上你可以使用  来替代，在 Windows上你可以直接在下载它。当然，KDE 不可能向国内的手机应用商店交钱上架，所以你需要在  下载最新的手机应用。  KDE Connect 的使用非常简单，一看就能明白。如果你还是无法检测到设备，检查一下你的 PC 防火墙设置。KDE Connect 使用 UDP 和 TCP 端口 1714-1764，确保你的防火墙放行了它们。    附录：scrcpy 快捷键  首先，需要设定  键作为前缀。默认是  使用  来设置。  序列|作用| |:|:--| |进入/退出全屏模式 |旋转方向 | Home 键 | Back 键盘（右击鼠标亦可） | 最近应用列表 | 应用菜单键 |调节音量 |关闭屏幕 |下拉系统菜单 |从系统剪贴板输入序列  参考  -  -  -", "url": "/articles/scrcpy+sndcpy+kdeconnect多屏协作.html"}, {"title": "我的2022", "content": "uuid: \"0b76294d-1212-48fa-98d0-f7fda869006e\" title: 我的2022 date: 2022-12-14 category: 杂感   2022年我做了什么  - 学习了前端开发。      从一开始不知道  为何物，瞎抄 CSS ，直接写  标签实现各种功能，到使用  添加动画，再到引入  ，再学习 Typescript 初次接触比较现代的前端开发，最后到现在学会用  配合  和 进行现代前端页面开发，顺便学习了 SCSS ，了解了 CSS 动画并使用了一些常见的 CSS 框架，以及了解了许多浏览器机制，算是来了一场「前端开发从远古到现代」之旅了。  - 学习了 Java 和 Kotlin 。      本着学算法（很奇怪）的目标，我开始学习自己一开始就不喜欢的 Java ，并且确实没有喜欢上这门语言。但无论如何，至少我现在能使用这门语言干活，虽然不是也不太可能成为 JVM 大师，而且 Java 水平也就在一个「刚刚能上手」的水平。      至于 Kotlin ，学习它自然是为了能够替换 Java ，顺便给 Android 开发铺垫一下。虽然我依旧不太喜欢 JVM 语言就是了。  - 简单的后端开发，数据库和缓存的知识      有前端必然有后端，下半年基本上在倒腾一些经典的玩具项目诸如「作业管理系统」，「班级管理系统」，「博客管理系统」等等，并且参与了一个实际项目的开发，我算是把前端和后端结合在了一起。一开始使用 nodejs 前后一致，到后来后端用 Java 和 springboot ，顺便把 sqlite, postgresql, redis 缓存, openapi, 乃至 grpc 都折腾了一圈，虽然不敢说在哪个方面达到精通水平，但至少算是入了门，顺便锻炼了 Linux 乃至 openBSD 的运维能力。  - 半途而废的其他      我还尝试了其他一些语言/框架等，不过没有坚持下来，要么是火候不够，要么是与我水土不服      - Golang ：我尝试了一下，但是我对它的语法感到很难受很难受，缺乏类机制和异常也让我用起来很不愉快，再加上难以名状的网络环境......我觉得除非工作需要我应该不会再碰它了。      - Ruby on rails ：它大而全，所以当我一开始想要学习它的时候根本不知道入口点在哪里，再加上网上的资料多半过期，ruby 语言热度又不高，遂弃。      - Raku & Dlang ：它们很好的语言！但是现在已经不是20世纪90年代了......      - C# ：很简单，我没法在 linux 上使用 Visual Studio ，更没法在 Linux 上面运行带图形界面的C#程序，更别提开发了。      - Emacs ：很多人一开始纠结于如何退出 vi ，但对于我是如何退出 emacs。  - 除此以外......  完整的看的实体书有半本《计算机程序的构造和解释》以及《Java核心技术》两本。《算法》看了半本但没怎么看进去。《CSAPP》只看了一点点。  俩项目，从开发到部署到维护<del>到下线</del>，焦头烂额（  2023的计划.  首先，要活下来。  我也知道在 21 世纪的今天把目标定为「活下来」是有点不可思议，但是现实就是那么魔幻。「天地不仁，以万物为刍狗」，病毒可以对人类一视同仁，但人却不是这样。我希望自己，自己的家人，朋友们都能够平安度过这一年。  在计算机方面，不如去回归一下初心，去「追寻一下隐匿在计算机里的神灵」好了。所以一方面我打算重新学学 C 和 C++，倒腾下数据结构和算法，另一方面继续学 Lisp 和 Emacs，「计算」这件事情本身也很有意思。前端什么的，我还想再学学 Vue，顺便多了解一些 Javascript 。至于 Java 和 Kotlin 的话，如果有需要再说。其实我还想学 Rust，不过这个愿望看上去是很难实现了。  其实情况一直会变化，有计划也很难准确执行毕竟咱不是计算机系的学生，学习起来也很难有一个系统路线，经常是想到哪里学到哪里，或者需求啥学习什么，只能尽力而为吧。", "url": "/articles/我的2022.html"}, {"title": "LRU-Cache与functools", "content": "uuid: \"809dd759-e6d9-4bb0-8e9b-31e48c7a9366\" title: LRU-Cache与functools date: 2022-12-13 category: 算法   啥是 LRU Cache  LRU的全称是 Least recently used，也就是「最近最少使用」，这是一种用来管理缓存的机制。缓存的容量是有限的，不能无限制的放各种数据，通常，在缓存里面放容易命中的常用数据肯定比放冷门的数据好，LRU机制假设一个数据如果在最近一段时间没有被访问，那么它在未来被访问的可能性也比较小。由此，在缓存满了以后，就通过淘汰最近没有用过的数据项来更新。   实现思路  先陈述一下思路，目标是实现一个  类，可以参照  上的题目来做。  实现一个朴素的 lru cache 需要两个容器，一个双向链表 (item) 用来保存数据权重，一个哈希表 (key:item) 用来保存实际的数据，和链表相互配合。除此以外还需要一个缓存最大大小。保存实际数据的是一个类似于 pair 的结构 LRU_Item ，使用  来推导类型。    当访问一个数据项时，从哈希表中寻找目标，如果找不到，返回这个模板类型的默认值，否则就命中缓存项目，之后，更新权重表，将目标 key 提到列表的最前面即将该数据移至链表头部。当插入一个数据项目时，如果已经存在项目 key ，删除旧项目，之后作为最新的项目在链表的最前面插入，再检查缓存大小，将多余的项目排除。虽然使用一个定长的双向链表也能实现，但使用哈希表降低了操作的复杂度。  举例：假设有一个 Cache ，其容量为2，首先插入一条数据  :    接下来插入一条数据  :    接下来获取  ，则返回结果后缓存内容变为：    可以看到  被提到了最前面。如果在这时再次插入一个  ，由于容量为2，最不常用的也就是处于列表最末尾的元素被移除，新的元素插入开头:    C++  以下是 C++ 实现的 LRU-Cache 类：    测试用例（采取 leetcode 的测试代码）：    请注意，这里的代码并不一定是最佳的解答，效率和性能也不一定最好，但求清晰。  Python  双向链表的模拟  当然也可以采用 Python 实现。使用一个 list 和一个 dict 可以轻松的完成任务，但为了和设计一致，在这里使用 python 的列表来模拟循环双向链表(这也是  的实现方式)。  不得不吐槽，你必须把自己的思想扭曲到一定程度才能熟练而自然的在 python 里面模拟指针类型和循环双向链表，以下是一个实现：    虽然在这里「模拟」出了双向链表，你以为的链表内容:    但其实是:    这也就意味着，但凡是比较大的列表，就会  。  那么接下来使用这个脆弱的双向链表来实现一个脆弱的 LRU_Cache ，注意，和 C++ 实现不同，这里的 item_list 是反过来存储的，也就是最新的元素插入在右端，去除的是左端的内容:    这个实现可以通过测试,<del>但也只保证通过测试(</del>  collections.deque  其实使用双向链表之类的目的在于能够快捷的处理「在初始插入」之类的操作，但这种操作在标准库  中已经被  提供了。 是一个内置类型，使用 C 实现，位于源码  ，库路径位于  。它提供了  ,  这类操作。  对于 deque 来说，删除任意位置元素可以这样实现：    再将删除的元素重新排到末尾即可实现  。其他的操作和之前类似。  functools  所谓装饰器，可以理解为「操作函数的函数」。实际上就是定义了一个函数，这个函数接收另外一个函数，作出一些修改，再返回这个函数。而「装饰器」是这个过程的语法糖。  @lru_cache   的函数原型是 ，使用 lru 缓存机制，可以设定最大缓存数量。真正的缓存实现位于  函数中。该函数使用列表模拟的双向循环链表+ dict 的方式存储缓存。  可以像这样来使用：    结果：    可以看到 lru_cache 显著降低了时间。  参见  -  -", "url": "/articles/LRU-Cache与functools.html"}, {"title": "Python的more-itertools模块", "content": "uuid: \"426704c4-a51f-470c-a9c9-f3e3ecc43bfc\" title: Python的more-itertools模块 date: 2022-12-08 category: 学习   前提  所谓程序就是“一定的环境中处理数据”，日常编码中总是会碰到“在一个序列的数据中过滤”和“对序列中的每一个项目操作”这样的需求，我们可以这样做：    也可以类似Javascript这样:    当然，Python虽然提供了，函数，但是不能够和JS那样链式调用，不过本文介绍的是比，更加强大的函数们。  迭代器  简单的来讲，所谓迭代器，就是一个懒加载的列表。有一个指针指向“目前的项目”，调用这个指针就会“消费掉”这个值。而使用就能把整个迭代器变成列表。  迭代器比列表更加节省内存，因为每一个值会在需要的时候才计算。但是同样的，如果你试图把一个无限的迭代器转list，那就会爆内存。  itertools  是python提供的标准库，包含了许多帮助函数。这些函数的教程网上已经汗牛充栋，这里只提几个：  Accumulate : 迭代操作器  按照字面意思翻译，这个函数应该叫做“累加器”，最基础的使用方法也是累加：    这个函数相当于：    可以看到这个函数的第二个参数是一个函数。你可以给任意一个“输入两个值输出一个值”的函数，然后一步一步得到它的结果。换成就是阶乘（）；换成就是带过程的取最大值。  Groupby : 数据分类汇总  假如你有这样的数据：    你想拿到这样的结果：    就可以使用这串魔法：    其实也不是那么魔法，最重要的就是这一串：    同样的，groupby函数接收两个参数，一个是迭代器，一个是函数类型，用来指定分类的key。可以理解成SQL中的。返回类型是一个二元元组，(这个key，包含这个类别的元素的迭代器)。接下来就可以使用来转换了，这也是的作用。  :::{.note .blue} |     | |  | | ℹ️ groupby 在使用之前一定要对数据排序好！ | :::  还是看不懂？那就看这个版本吧：    Product : 全排列  假如你有'ABCD'和'xy'，你想要得到的排列组合，那么你就可以使用  来得到。很简单。函数签名是这样的：，也就是你可以给出任何数量的迭代器。  Pairwise : 成双成对，藕断丝连  的用法很简单：  它的实现方式类似于：    more_itertools  好，现在进入高阶魔法阶段。这里将会一边介绍用法，一边简单分析源码。准备好：）  一变多系列  输入一个迭代器，返回多个结果的类型。  Grouper    按照给定的长度把一个可迭代类型分组。得到一个迭代器，里面包含指定长度的元组。    不过并不是每一个迭代器都能正好是整除你的，所以和控制不同的表现。假如你的分组目标是\"ABCDEFG\"，n=3，那么：    这玩意的实现机制很简单：  首先，如果你要展开一个iter，可以在它前面使用号。比如就会打印出。  首先判断，如果是，就直接上zip，否则，如果是的话，就使用，是就使用。但核心是一样的，以模式为例：    注意到会创造出一个包含个迭代器的列表，其中每一个迭代器的内存地址是一样的*，操作一个就是操作全体！那么：    在这里，zip函数第一次取得的并不是，而是，因为每一次取得，所有三个指针的位置都会向前移动一格。  Partition  ：返回两个可迭代元素作为元组，前一个不符合你的条件，后一个符合你的条件。可以用来把一个迭代器一分为二成两个部分，<del>不同意的请站到左边，同意的请站到右边</del>。它的使用就比较普遍了。还记得文章开头的那个例子吗？就可以用这个函数来处理，这里另外举例。    Divide  顾名思义，这个函数把一个可迭代序列分割成若干个子迭代器。    函数签名是。其实现为，首先，尝试对进行一个下标操作，通过捕获异常来判断类型：    接着，使用来获取商q和余数r。是一个Python的内置函数，用来同时获得商和余数的元组。然后按照步长结合q,r截取原来的列表构建结果列表：    可以看到总是能够保证得到的结果会是个迭代器。  Split_XXX 系列  对于字符串，可以使用这样的方法把字符串分割成列表，那自然我们也希望能够对一个可迭代元素这样操作。函数接收的不是一个字符串而是一个函数，如果序列内的元素返回真，就在这里分割。其函数签名如下：。其中，是判断函数，是最多分割次数，决定是否保留真元素。    库里面还提供了其他几个函数，举例说明。约定，则：  | 函数      | 描述 | 示例 | 结果 | |  |  |  |  | | | 按照指定条件分割序列||| | |在返回真的元素之前分割，保留真元素||| ||在返回真的元素之后分割，保留真元素|||  整个系列都有类似的实现。首先判断，为0就直接。再遍历原来序列的每一个元素，判断并按照要求即可：    注意这个函数返回的依旧是一个generator object，所以最后使用yield关键字。假如使用的话，首先会两次，把前面两个0放到结果中去，然后遇到1，直接把buf yield出去，下一次再进入时，buf再次被置零为空列表(第一个yield下面一行)再继续操作。最后遍历全部完成，再把剩下的返回。buf就是保存每一次结果的列表。其他split系列的函数实现类似，略有不同。  有两个函数与众不同，一个是，这个函数接收的条件判断函数需要两个参数，返回真时则在这两个元素之间分割。例如，对输入，判断函数拿到的就是这样的一组元素。实现上就需要用到双重指针了，一个指向目前项目，一个指向未来(next)项目。    另外一个是函数，很简单，就是按照sizes指定的大小列表分割：    实现起来相当简单，遍历sizes切分即可，基本上就相当于(所以返回的依旧是迭代器)。  多变一系列  Flatten  打平，也就是把变成这样的。可以想到把每一个每个子列表链接起来即可：    然而，如果输入是多层嵌套的就会失败，假如输入，结果是。这种时候需要使用。  Collapse  用法不多说了，很简单。把一个多层嵌套的列表“打平”是常见的操作，一个常见的思路是使用递归：    如果把它改写成生成器的写法就变成了：    把for循环写到里面去，就变成：    这其实就是库的实现方式。不过它把内部循环单独实现了一下，限制了递归级数，并且加上了对bytes,str和用户定义的“不处理类型”的处理：    它的函数签名是，可以指定不处理的类型和递归层级。  Unzip  是标准函数的逆向过程。很容易理解，就是“先取每个迭代器的第一个组成第一个结果，再取每个迭代器的第二个组成第二个结果......”，实现方式类似于这样：    最终的结果是。库的实现是嵌套函数，并且返回的是一个类型。但是请注意，如果输入类型不是严格匹配，参差不一的话会抛出，其中的<del>间谍</del>的作用是拿到第一个元素和整个迭代器的副本并不去调用__next__()：    挨个操作系列  Map_except  很简单的函数，如果你有一个参差不一的列表想要但不希望因为里面有一堆不想要的数据类型导致抛出异常就使用它。此函数会简单的忽略出现的异常：    可以接收多个exception类型作为的参数，除此以外的不会被捕捉。当然，可以给一个基类捕获一切异常。其实我来设计的话我会给它加一个默认值：    Map_reduce  组合拳，略复杂，看例子：    Numeric_range  假设你要遍历1到10，你可以使用，自然你也希望有一种方法可以遍历日期，分数，小数，乃至一切你直觉上觉得可以按照一定间隔遍历的东西，比如 这样，那么就是你需要的：    首先，是一个继承了和的类，这也就意味着它并不是一个。按照文档，继承了就要实现一些方法：    与函数相同，它的构造函数也接收一到三个参数，即起，末和间隔。无论给出的是多少个参数，在构造函数 中会生成,,代表起，末和间隔。为了自动推导出来，在构造函数中使用了一些技巧，也就是函数。比如给出参数，那么会使用这样的方法得出 第三个参数(自动指定间隔为1)：    可以处理int的key或者slice的key，按照不同的类型返回不同结果。如果是简单的获取指定位置的元素，只需要即可。  同样的，使用就可以得到这个类型的0值。除此以外，构造函数还需要判断给出的起末是递增的还是递减的，这个判断使用来实现。最简示例如下：    过滤器系列  Strip 系列  像字符串的函数一样，对一个序列进行操作，去除末尾元素。不过接收的是一个函数类型：    的实现就是一个，而使用一个列表来处理符合条件的元素：     Filter_except  和类似，不过是一个过滤操作：    参考  -  -  -", "url": "/articles/Python的more-itertools模块.html"}, {"title": "React+Redux简单使用", "content": "uuid: \"8535e383-e302-48c1-849a-d0c4447265f4\" title: React+Redux简单使用 date: 2022-12-04 category: 学习   缘起  我需要使用到 redux，找到的教程要么是阐释 redux 设计的大道至简精深奥妙超凡脱俗出类拔萃，要么是只有方案没有解释的片段，难遂我意。所以我在自己摸索以后做一个简单记录。  场景  Redux 所适应的场景是需要处理很多复杂数据，并且这些数据被页面上不同的组件依赖和改变。例如，需要制作一个日历 APP ，包括一个日历，显示事件的窗格，显示这一天心情的窗格， 用户点击更改日历上的日期，另外两个窗格也需要更改内容，那么它们都依赖于一个全局的数据源，如果使用传统的方法，在各个 React 组件里面传入一个函数处理，很快就会凌乱不堪， 所以需要一个统一管理这个「全局变量」的东西，实现各个组件订阅数据，一旦改变，各个组件都能够接收到改变的功能。那就是 redux 了。  我设想的情景就是这么一个网页 App ，并且需要使用 React 实现三个组件。在改变日期时还需要从服务器动态获取数据异步加载。  使用  Redux 方面  首先需要安装 redux 。使用的是  。react 项目直接用  来创建一个脚手架项目。  使用到 redux 的项目一般不是一个  就能够解决的。一般来讲需要创建几个不同的目录：  - store.js  用来保存初始状态和整个 redux 的配置 - features  一个目录，用来保存 app 的各个功能需要用到的数据 。  一个 app 是复杂的，比如本文的 app 三个组件，日历组件可能需要时间，日期，这一天星期几；事件查看机需要一个事件列表；而心情窗格需要心情，额外文本等。每个部分的功能所需要的 数据某种程度上独立，但都统合在 store 里面相互影响，比如，星期几的改变会改变另外两个的内容，所以每一个组件所定义的「全局数据片段」保存在单独的 feature 文件里面。所得到的就是各自的 。  如果把redux想象成全局变量管理器，这个全局变量，也就是store需要有一个初始值，分解到每一个Slice，它们各自都需要定义自己的初始状态，才能成为整个store的初始状态。 Slice文件不仅定义的这个组件（功能片段）的数据定义和初始状态，也定义了改变状态的方法，也就是。对于redux来讲，reducer需要是一个纯函数， 接收一个状态，返回一个状态。白话来讲，就是：，其中是老的状态，是这个reducer的发起者（比如点击日历日期后的事件处理函数） 发送的关于怎么改数据的action，返回一个新的状态。这个有具体的格式，必须是这样的：    进行reduce的操作叫做。 幸运的是，react-redux 这个toolkit给了很多便捷的方法来创建这些东西。  一个slice（日期组件）的举例：    这就成功的创建的一个slice了。一般就保存为。  其他的几个组件都是类似的定义，那么最后还需要一个总的store的设置：    这就创建了一个全局的store，内含三个组件的Slice，共同组成一个“全局数据”。如果直接看的话，它的内容应该是这样的：    那么比如要得到目前这一天是不是假期，就可以用来判断了。  React方面  光有数据不行，还要能够显示和改变它们。redux的store需要一个“订阅者”来使用这些数据。也就是React组件。虽然React支持函数式和ES6 Class两种类型，但是react-redux更加偏向使用函数类型(<del>虽然我喜欢写class</del>)。  众所周知react组件需要props和state，那么在结合了redux以后，和app整体的数据有关的，比如日历组件的日期和更改日期，就不再采用props，state了，而与app整体数据无关的，比如编辑器显示的目前输入的字符数量之类，既不需要全局数据，也不会对它产生影响，依然可以使用旧的方法处理。  “订阅”数据  只需要在根元素上面“订阅”一次就可以拿来使用了，redux会自动初始化各自的数据：    组件获取数据  各个组件需要自己的那一份slice，而不是把整个store的内容都拿来，这就需要对目前的store内容进行一个选择。 在react-redux中，就是用来给组件自己的那一份数据的，以日历组件为例：    每当store中的calendarStatus因为某种原因改变了，slice也会改变，并进行重新渲染，某种意义上来讲它类似一个。  组件更改数据  一般在子组件需要更改外部数据，会在props里面设置一个状态提升的函数，当事件发生时调用它来传出去，在redux里面，一个组件要修改store的数据，需要使用dispatch的方法。相当于一个邮递员，帮助组件把信息传递给对应的。依旧举例日历组件：    在这里，使用了dispatch来调用之前预先定义的函数，而的作用就是把消息包装成标准的action类型发送出去。包装出来类似这样：    然后再去调用，其中的state自动是原先的状态。改变之后，在通知所有的订阅者。流程就是这样。  异步操作和在组件外进行dispatch  初始化时fetch内容  没有ajax或者fetch的web是不可想象的，假如用户更改了时间，或者修改了这一天的事件，就要把数据传输回服务器或者请求过来。传输回去直接开一个fetch即可，但请求就有点麻烦，必须要考虑异步问题。  比如说，在初始化时fetch内容，这是很常见的需求，一般可以结合UI框架的或者类似的组件实现一个\"加载中请稍候\"的功能，等到初始化完毕再显示。解决方法可以是，现在store里面保存一个全局的，各个组件检测它，如果为真，就显示内容，否则加载中。这就涉及到在全局数据fetch完毕以后在react组件外部触发reducer。  其实是可以的，因为redux本身不依赖于任何框架。react-redux只是提供的快捷方式而已。且看dispatch的定义：    所以，你需要生成对应的type字段。在例子中，假如这个保存在中(也就是这个Slice文件的是)，reducer名字是，那么手动触发的程式码如下：    组件内fetch内容  当用户点击一个日期后进行切换，那么另外两个组件在加载完毕数据之前应该显示一个\"loading...\"之类的提示，一旦加载完毕马上显示出来。  为此需要这个功能。首先是在相应的Slice里面定义一个Thunk函数，且看定义：    三个参数 ，是一个string，也就是用来识别这个action的字符串。对应的就是类似即action类型的。是一个Promise，可以省略。那么，如果要给日历组件写这个chunk，应该是这样：    其次是为这个slice创建额外的reducer，不同于一般的reducer函数，Promise有三个状态，,,三种情况都需要处理。react-redux为我们提供了来处理这个情况。在原本的中修改：    参见  -  -", "url": "/articles/React+Redux简单使用.html"}, {"title": "Kotlin笔记(1)", "content": "uuid: \"49154284-8978-4e9b-81d9-e5cfa757dcea\" title: Kotlin笔记(1) date: 2022-11-24 category: 学习  开发环境  IDE  - IDEA () - VS Code () + Kotlin 插件()  REPL  打开使用REPL  数据  val  是不可变类型（只读变量）。运行时指定，不可修改。    var  是可变变量类型。    const val  是编译时常量，必须在编译时是已知的基本数据类型。必须放在最外层。    基本数据类型  |类型|描述|举例| |||| |String|字符串|\"Hello!\\n\"| |char|单个字符|'x'| |Boolean||true| |Int|整数|114514| |Long|长整数|999999999| |Byte|8位整数|126| |Short|16位整数|32767| |Float|32位浮点数|3.488| |Double|浮点数|1919.810| |List|列表|略| |Set|集合|略| |Map|散列表/字典|略|  字符串  1. 字符串截取：使用 2. 字符串分割：使用 3. 字符串替换字符：使用:        4. 字符串比较：可以直接使用(与Java不同)：            5. 遍历字符串： 一个字符串就是一个不可变的字符列表，所以能用在list上的都能用在字符串上。  数字  字符串转数字  - toFloat - toDouble - toDoubleOrNull - toIntOrNull - toLong - toBigDecimal  等。每一种都有版本，返回可空类型，便于使用运算符避免抓异常。  数字格式化  按照C语言的格式化字符串规则展开即可。  位运算  - 直接把数字转换为二进制 - :按位左移 - :按位右移 - :按位取反 - :按位异或  List列表  列表是kotlin的基本类型。分为两种，可变列表和不可变列表。  创建    获取与遍历  获取  1.  : 可能抛出异常。 2.  : 便于使用处理null值 3.  : 使用lambda获取默认值，例如  遍历  1.  : 带索引的遍历 2.  : 没有索引的遍历  都是携带一个lambda函数。注意要使用来执行lambda!!!  修改  只有mutableListOf才能修改。有add和addAll两个方法。  解构  List 集合支持以解构的方式获取其中的元素。   split 函数返回集合数据后,集合里的前三个元素就分别赋值给了 type、 name 和 price 这 三个字符串变量。通过使用_符号过滤不想要的元素。  Set集合  Set是会自动去重的集合类型。和List类似，有可变与不可变两种。Set和List可以互相转换。使用和即可。 Set的创建方法如下：    类似的，使用,,,,等函数处理可变的Set。  对于线性的容器，可以使用这种方法方便快捷的取得随机元素。  Map散列表  Map即类似于python中的dict或C++中的map。现代的常用程式语言没有在语言内置散列表的功能是说不过去的。Kotlin的Map用来存放 一组元素,默认只读。创建方法如下：    其中是个省略了点号和参数圆括号的特殊函数，把它两边的元素转换为一个（）。 读取方法是简单的方括号，也可以使用,来防止null异常。注意使用匿名函数。 一般情况下，需要使用类似这样的代码来检查和添加元素：    但在kotlin中只需要一个函数即可，很方便。  其实，有IDEA这样的IDE并不需要记住这些函数的原型，一般只需要猜即可。放入操作大凡是put，取出则大凡是get。  控制流  if,else,while,for等等控制流不必多言。  导入的话，可以类似python用了。    由于Kotlin比较灵活的语法，可以写的更舒服。有一种TMTOWTDI的意思了。  (话说回来我觉得Python的不好之处就在于一些全局函数，比如不得不使用之类的函数，而不是在各种对象上调用的方法。 即使对象有内置的方法，而且Python的lambda比较弱)  函数  匿名函数  <del>约翰·麦卡锡和阿隆佐·丘奇们的英灵可以告慰啦！现代语言几乎都支持匿名函数和函数式写法，哪怕 大家并不知道啥alpha转换，beta规约（</del>  再加上几个标准函数，真的可以做到函数式一把梭。（apply, let, with, run, also, takeIf, takeUnless)  稍举一例：   扩展函数  扩展可以在不直接修改类定义的情况下增加类功能。javascript可以使用这样的方法给已有的类添加方法：      null安全  在类型后面加个问号表示可空类型。例如。  使用（安全调用运算符）来防止在null上调用函数出现，可以使用来强制调用，跳过检查。 使用来实现类似Javascript中的取值。", "url": "/articles/Kotlin笔记(1).html"}, {"title": "仿Github热力图设计", "content": "uuid: \"7f47edb7-e725-491a-b870-567ba2c80029\" title: 仿Github热力图设计 date: 2022-11-23 category: 技术   起因  我希望能够给自己的日记项目升级一下，参考Github的贡献热力图，构造一个类似的组件。查看了一圈，要么是比较老的库，要么不提供我熟悉的框架，再 加上我的需求其实很简单，于是决定自己实现一个简单的热力图。  需求  !  首先它需要和Github的热力图看上去类似，我就不做的那么细致，直接20个星期，每个星期7天，一共140天。不标注月份，但在左侧标注星期几。  为了好看，要求本日固定在右下角的最后一个格子，星期显示自然要跟着同步。除此以外，鼠标划过需要在右下角显示这一天的日期。 其他的组件，图例，颜色，黑夜模式什么的可以日后再调教。  思路  界面构成  我看了一眼Github的前端，发现小格子都是按列排的元素和元素。肯定这样是性能更加高，不过这么一来还需要 学svg，<del>总之，我有一万种偷懒的理由</del>，最终决定使用+CSS画格子。  这样的构图很容易就想得出来创建一个矩阵，每个格子对应座标，而每一列作为一个组件，用flex排一下。  数据格式  最方便的就是JSON传个矩阵过来，但这样太肥了。所以打算按照间接寻址来算。以右下角最后一个格子(19,6)为0地址，把整个 热力图矩阵看作是一个线性数组，一直向前推即可。比如8就是对应(18,6)。而每一个方格只有固定的几种可能性，按照绿色的 程度分为1，2，3，4四个级别，0为没有颜色。因为大多数方格是没有颜色的，所以只需要把1，2，3，4四个级别包含的格子指明 即可推出整个矩阵。  整个Component的props格式定义如下:    而组件内部的status就很简单了，直接根据props推出来整个矩阵即可。每个矩阵元素保存该方格的level。    组件  分三个层次，整个组件,列,和单元格。  HeatMapElement  很简单，需要的props为座标，level和一个状态提升函数。座标用来传递给状态提升函数，level进行字符串拼接转为传为className 给CSS。整个组件写成function component.    HeatMapColum  用来包含小方格的组件，props为x座标，相应矩阵的数据切片（代表这个星期），以及一个状态提升函数。    如果想要避免for循环，直接在里面开数组，就用就地创建。  HeatMap  最主要的组件。比较长，不全放上来。    主要值得注意的是的处理和使用来创建矩阵。  其他杂项  CSS  很少啊很少    实现  使用实验数据:    最终结果是这样的：  !  TODO  - 用svg来替换div - 适应手机端", "url": "/articles/仿Github热力图设计.html"}, {"title": "CSS_Tooltip技巧", "content": "uuid: \"9a1f2f73-527f-40cc-b3ad-3ca0d7380bf9\" title: CSS_Tooltip技巧 date: 2022-11-14 category: 技术  可以使用纯CSS实现Tooltip  原理是使用,伪类和来动态添加内容。Tooltip的内容可以使用来获取。  具体实现:    这个Tooltip类可以加载几乎任何html标签上。比如一个普通的文字：    结果就会是这样：  !  参考：MDN上的示例:https://developer.mozilla.org/en-US/docs/Web/CSS/::after(~~比较难看的Tooltip~~)", "url": "/articles/CSS-Tooltip技巧.html"}, {"title": "Lenovo Legion R7000 安装 openSUSE", "content": "uuid: \"27229a58-7f89-47b6-b217-54f35d638fb1\" title: Lenovo Legion R7000 安装 openSUSE date: 2022-07-13 category: 杂项   Lenovo Legion R7000 2021 + openSUSE + i3wm 配置  1. 不要使用openSUSE Leap，目前的Leap(15.3)无法识别无线网卡驱动。Tumbleweed可以识别。    2. 在BIOS设置里将输出设置从\"集显输出\"改为\"混合输出\"，否则在suspend后无法苏醒。    3. 如果使用KDE，避免使用Wayland模式，否则CPU占用会暴涨导致无法使用。     1. 操作系统安装  我原本使用的是KDE Neon系统，它在我的老电脑上运作的很好，但我打算在新的电脑上使用非基于Ubuntu和dpkg的系统。Arch太复杂了，最后选择了openSUSE。  openSUSE有Leap和Tumbleweed两个分发，由于滚动更新曾经搞坏过我的系统，我首先选择了Leap。但是安装出现了两个问题：  - 无线网卡没法显示出来。安装以后也识别不出来。可能是因为Leap的内核版本太老了。    - Xorg无法正常启动。虽然我安装的时候选择的默认启动模式是图像界面，但进去还是tty，并且没法启动Xorg。不知道是什么问题。     所以我最后安装了Tumbleweed。滚动更新那就两个星期滚一次。而且之后我了解到SUSE使用的btrfs有快照功能，就不用怕滚坏掉系统了。  安装的过程很顺利，Tumbleweed可以识别所以的硬件，并且安装以后(保险起见我还是安装了KDE全家桶)也可以正常的启动。  2. Nvidia驱动安装  这台电脑用的是RTX 3050显卡，我不懂这些型号而且也不玩游戏。不过有一个超棒的显卡似乎也不错，那我就觉得要安装一下Nvidia的私有驱动。我按照指南上的成功安装了。    不过注意安装要在tty模式进行不然可能会出现什么幺蛾子(  安装完毕以后就可以打开调控显卡啦！  3. 窗口管理器安装  我以前一直使用KDE全家桶，不过一来我想尝尝鲜，二来买这台电脑没有送我鼠标，最重要的是这个电脑左右两侧的USB口只有一个，导致我根本不够用，所以我打算使用平铺式窗口管理器。  我参考了一些最后选择使用i3-gap，因为它不只是只有平铺一种模式，也可以切换为浮动模式，这样要是我愿意也可以换回去。而且比起原版的i3，它多一个gap，所以不同的窗口之间可以有空隙，更加好看！软件源里面就有i3-gap所以只需要    就可以了。然后众所周知平铺式窗口管理器强烈依赖于键盘(好在Fn+Space切换键盘灯依旧可以用)，所以需要大量的配置。我把大量的快捷键重新map了一遍，<del> 这样其他人就没法用我的电脑啦！</del> 这其实蛮困难的因为总是有好多矛盾的键。我使用了Mod1(Alt)和$Mod(Super)这两个功能键。我打算以后配置完整了上传github备份一下免得丢了。  4. 多媒体解码器安装  openSUSE没法直接播放mp3之类的格式，据说是因为版权原因巴拉巴拉的什么，总之，要想正常播放多媒体，直接安装vlc肯定是不行啦。所以需要一个叫做的第三方源来安装<del>甩锅</del>这些解码器。具体的来讲就是：    三条指令执行下来就可以播放电影和音乐啦！  5. 下拉终端  这个对我来说很重要，就像对一个人讲话一样，时不时对电脑讲一两句，专门打开一个shell再关掉就太麻烦了。所以需要下拉终端。  我考虑了我以前使用的KDE的，但是它有一些问题，首先是没法正确的混成。导致只有一半的窗口被渲染；其次是它没法正确的被对待为一个\"下拉窗口\"，总是被i3当作普通的窗口，一下子就占满整个屏幕；最后kde系列软件需要的软件包好多啊。所以我选择了另外一个下拉终端，虽然我真的很不喜欢它的名字\"挂科\"......  6. 终端模拟器  默认的终端模拟器(就是$mod+Shift+Enter启动的那个)是很丑很丑的。虽然配置一下也可以很好看，但是我决定使用其他的模拟器。我选择了。本来是想用的，但是它对于中文输入法似乎支持不够友好，所以即使有很多好功能，比如标签页功能(可以用替代)，也没有选择它。  7. 壁纸  壁纸当然是使用来设置。我本来想使用搞一个动态的视频壁纸，但好像和混成器起了冲突。    记得加在i3的配置文件里面自启动。  8. 状态栏  当然是使用啦！我在github上下载了著名的里面的主题。不过要注意，里面的东西不能直接用而是要按照自己电脑的实际情况改动。比如里面关于显示wifi状态的网络接口名称每一台电脑都不一样，又比如显卡的亮度读取amd和intel也不一样。  这些东西，包括栏的显示的内容都可以直接改它的主题文件。具体的就是里面的,和这些内容。可用的模块可以在同目录里面的和    里面找到和更改。最后启动只需要在i3 config里面exec 主题文件夹里面的就可以了。  另外，原版的也可以保留。我是默认隐藏，只有按特殊键才会显示。里面的内容是一些诸如IP地址之类的不常用的信息。  9. 混成器  混成器我使用的是，还有一个可以选择，但是两个软件似乎是矛盾的，安装一个就会自动卸载另外一个。不管怎么说其实都很好啦！  不管需要注意的是，zypper安装的只有这一个模糊方式，如果需要其他的实验性模糊后端必须自己编译github上的源码。  10. 网络管理  <del>其实也不是是不能用</del> 使用就解决了。  但还是有问题：总是扫描不出wifi网络。不知道是驱动的问题还是的问题了。总之思考一下以后我使用另外一个方法上网，使用手机的USB tethering功能，即插即用完全不用密码什么的。  11. 输入法  如果在安装时候选择中文，或者安装以后在yast2里面更改语言为中文，那么中文输入法，词库，字体都会一股脑自动安装上来直接就可以使用，但是，一旦把语言改回英文，yast2就会自作聪明的把这一切都删光光......  所以，最好的方法就是自己手动安装一下了。我安装的是和输入法。    安装成功以后，还需要在里面启用安装的输入法才可以使用。最后不要忘记把守护进程添加到i3的自启动里面。    12. 锁屏  锁屏是很必要的。然而i3lock实在是太简陋了，所以有很多加强版的快捷锁屏。  - i3lock-fancy      仓库地址是 https://github.com/meskarune/i3lock-fancy.git      这其实是一个shell脚本，用来调用原来的i3lock，可以设置截图背景模糊灰度之类的。其实和自己写一个脚本调用convert和scort差不多但是别人写的更方便通用一些。    - i3lock-color      仓库地址是 https://github.com/Raymo111/i3lock-color      这个是fork的原来的i3lock并且加入了许多高级功能，比如可以更改显示位置，显示时间日期什么的。需要自己编译，或者也可以直接下载release。在仓库里面目录里面有demo脚本可以自己改。    - xsecurelock      这个和i3lock没有关系，是谷歌的独立项目。好处在于首先是安全，其次是可以使用mpv作为后端来搞动态锁屏。需要自己编译。     13. 背光调节  <del>我看网上的i3背光调节都是使用但是我的完全不起作用，所以我自己用写了一个脚本绑定快捷键，聊胜于无吧.</del>   不起作用的原因：   only works with Intel. Other drivers (e.g. Radeon) did not add support for the RandR backlight property.    14. 通知管理  其实通知并不是很多。所以简单地使用dunst再抄一份官网上的配置文件就足够了。  15. U盘自动挂载  相比与完整的桌面环境，i3好像没有可以自动挂载的机制，所以需要手动操作。但是每次sudo mount实在是太麻烦，我找了一下，可以使用来自动操作。那就下载一个好了。  缺点在于，现在i3的自启动daemon有六七个之多......", "url": "/articles/Lenovo-Legion-R7000+openSUSE.html"}, {"title": "交换类排序", "content": "uuid: \"3fff20fc-0bcc-497f-a3e2-79c5ca797426\" title: 交换类排序 date: 2021-07-28 category: 学习   在交换类排序算法中，已知最好的选择算法是快速排序。  冒泡排序  很简单的排序算法，效率很低，但是简单易懂。初中就学过。具体的来讲，就是一遍一遍的扫描数组，碰见顺序不对的把他俩调换一下位置。最后还需要额外扫描一遍确保排序好了。这是一个原地的排序算法。    双向冒泡排序  和冒泡排序类似，但是每次扫描过后不是从头再来，而是从反方向扫描，减少总的扫描次数。同样是原地排序。    奇偶排序  和冒泡排序类似，但是步长为 2 。先是比较数组中相邻的（奇-偶）位置数字对，下一次再（偶-奇）比较位置数字对，如果该奇偶对是错误的顺序（第一个大于第二个），则交换。同样是原地算法。     皮匠排序  <del>很奇怪的名字</del>，来源是算法导论 7.3 练习题。不过第三版已经改成  了（  - 如果最后一个值小于第一个值，则交换 - 如果当前集合元素数量大于等于3：      - 使用皮匠法排序前2/3的元素     - 使用皮匠法排序后2/3的元素     - 再次使用皮匠法排序前2/3的元素  很慢很慢。    快速排序  快速排序就是，选择一个基准元素，通常是中间那个，把大于它的放在一边，小于它的放在另外一边，再对两边的分别继续这样操作。最后就能得到排序好的序列了。  最容易理解的「标准版本」如下：    使用  来对数组排序。  除此以外还有一个原地排序的版本。常见于  等的实现。    使用  来进行排序。  参考：  -  -   另附： 写的简短版本（）：    测试  对上述排序算法进行测试，使用一个装饰器进行计时。    结果如下：  !  可以在下载测试代码。  除此以外，描述了很多经典排序算法，均为  实现：", "url": "/articles/交换类排序.html"}, {"title": "经典数据结构・单向链表", "content": "uuid: \"5d2a083c-a623-460a-9cfc-77666376e598\" title: 经典数据结构・单向链表 date: 2021-07-11 category: 学习   定义  In order to avoid the linear cost of insertion and deletion, we need to ensure that the list is not stored contiguously.  The linked list consists of a series of structures, each of them contains the element and a pointer to a structure containing its successor.  头文件：    实现  检测链表是否为空    检验是否是最后一个元素    寻找元素  寻找第一个匹配元素的位置，返回  如果没有找到。    删除元素  删除第一个匹配的元素，需要首先寻找到这个元素的前一个元素。    插入元素  在指定的位置插入元素    清空链表    创建链表头    测试例  编译命令：", "url": "/articles/经典数据结构・单向链表.html"}, {"title": "模版功能简介", "content": "uuid: \"87b181b2-202e-11ee-b1e5-84a93896bec6\" title: \"模版功能简介\" subtitle: \"好好利用本主题吧~\" date: \"1980-01-01\" category: \"测试\" project: \"测试\" ref:    - name: \"第一个参考链接\"     url: \"www.example_1.com\"   - name: \"第二个参考链接\"     url: \"www.example_2.com\"   Document metadata  Pandoc allows setting [variables] in the preamble of a Markdown document with a YAML metadata block, like this:    This theme's HTML template allows setting some, but not all, of the variables that Pandoc supports, including:  -    - Required - ,  - , ,    - Optional, set automatically from , , and  -  -  -  -    - Optional (text direction, like  or ) -  -    - Optional, only affects  tag -    - Optional. A list of strings to inject at the end of the  tag - ,    - Optional. A list of strings to inject at the start or end (respectively) of     the   It also supports some extra variables:  -    - Optional. Will render  wrapped in a link with this target if     present. -    - Optional. Will render a \"return\" link at the top of the table of contents if     present. -    - Optional. Text to use for the \"return\" link. Defaults to .  You can see all of these settings in action at the top of this page. For more information, refer to the [Pandoc manual section for variables][variables].  [variables]: https://pandoc.org/MANUAL.html#variables  Assorted prose elements  This theme of course supports the standard Markdown prose elements you'd expect, like paragraphs, bold text, _italic text_, and .  Pandoc Markdown has special syntax for some some non-standard prose elements, including [smallcaps]{.smallcaps}, [underline]{.underline}, and ~~strikethrough~~. Refer to the Pandoc manual for more information, but the basic syntax looks like    > _This text is [smallcaps]{.smallcaps}._\\ > _This text is [underline]{.underline}._\\ > _This text is ~~strikethrough~~._  Pandoc Markdown also supports bulleted and numbered lists, as expected:  - Bullet item - Another bullet  1. First bullet 1. Second bullet  But it also supports non-standard task lists:    > - [x] _Already done_ > - [ ] _Not done yet_  Pandoc renders task list checkboxes as disabled, so they can't be clicked. This theme inserts a few lines of JavaScript to make them enabled in HTML but disabled with JavaScript because it is the easiest way to apply custom styles to checkboxes. If you prefer the  appearance or don't want JavaScript, feel free to remove the  tag at the end of the theme template.  Side notes and margin notes  Side notes and margin notes work very similarly to how they work in [Tufte CSS], but made easier to use in Markdown with the [] Pandoc filter.  To get started, install  and pass  when invoking Pandoc, like the [Makefile] for this project does:    With this filter active, the syntax for footnotes becomes the syntax for side notes and margin notes (specifically, it is no longer possible for the document to use footnotes).    > _For example this is a side note[^example-side-note]. Side notes are numbered, > and the number shows at the anchor point in the body text at all screen > widths._  [^example-side-note]:   This is the text in the side note. It is smaller and only supports inline   elements, like bold or , but not lists or code blocks.    > _On the other hand, margin notes are not numbered. Instead, they hang to the > left and are only vaguely connected to the text, like > this.[^example-margin-note]_  [^example-margin-note]:   {-}  detects margin notes when the note starts with the text   . This is inspired by the syntax Pandoc uses for unnumbered headings.  [Tufte CSS]: https://edwardtufte.github.io/tufte-css/ []: https://github.com/jez/pandoc-sidenote [Makefile]: https://github.com/jez/pandoc-markdown-css-theme/blob/27d0aa58bfc6eafe296e2cef1900a39c9c2507a7/tools/build.sh#L57  Side notes and margin notes are fully responsive. When there is no space to render the notes in the margin, they will be hidden by default, and the anchor point will leave a clickable link to expand the side note inline. Try viewing this page on a phone to see how that looks.  Choosing a side note anchor spot  Side notes and margin notes look best when they anchor to text within the first ~500px of the text (this is where the first line will break on tablets). This ensures that the baseline of the sidenote and the baseline of the body text will align on the first line.  For example, note the difference between the side note and margin note exaple above. The side note anchors to the first line of the paragraph, while the margin note anchors to the last line. This makes the side note even with its corresponding paragraph, but makes the margin note look like it's hanging.  Sometimes the prose dictates where the margin note must attach, making the problem unavoidable. But when there's a choice of where to attach it, use this as a guide.  Code blocks  Pandoc Markdown supports a number of code block features. First, plain delimited code blocks with no syntax highlighting:   This is a code block. `    As well as delimited code blocks with syntax highlighting:  ruby def greet; \"Hello, world!\"; end `    Numbered and highlighted lines  Pandoc Markdown also supports attaching line numbers to a code block, plain or with syntax highlighting using the  CSS class:  {.ruby .numberLines} def greet; \"Hello, world!\"; end `    The line numbers are clickable and all have HTML IDs attached to them, making them linkable.  This theme extends Pandoc's code blocks with line numbers by allowing individual lines to be highlighted. Emphasize specific lines in a code block by adding various  classes for the lines you'd like to highlight, like this:  {.numberLines .hl-2 .hl-3} This is the first line. This line is highlighted. This line is also highlighted. This is another line. `    The  class is required for these line highlights to render correctly.  Line highlight limit  A quick note on line highlights: this feature is implemented in CSS, and is currently limited to a max line highlight of the 40<sup>th</sup> line. More lines can always be specified by adding [more lines like this] using the  variable:  [more lines like this]: https://github.com/jez/pandoc-markdown-css-theme/blob/27d0aa58bfc6eafe296e2cef1900a39c9c2507a7/public/css/theme.css#L539-L578    Tight code blocks  Another feature unique to this theme is is . Sometimes for drawing ASCII art it's important that there be no gaps between lines, so that things like unicode box drawing characters attach:  {.tight-code} One line of text Another line of text ┌──┬──┐ ├──┼──┤ └──┴──┘ `    As you can see, the difference is striking. Text ends up looking crammed together, instead of following the normal rhythem of the rest of the document, but sometimes this can be a worthy tradeoff when it matters that code lines touch.  Math  Pandoc Markdown supports [a number of ways][math-input] to specify LaTeX math. This project's  defaults to , which allows multiple forms of math input:  [math-input]: https://pandoc.org/MANUAL.html#math-input    This is inline: $a^2 + b^2 = c^2$.\\ So is this: \\(F = ma\\).  This is display math:  $$x = \\frac{ - b \\pm \\sqrt {b^2 - 4ac} }{2a}$$  And so is this:  \\[\\frac{   \\Delta \\, \\Gamma, e : \\forall (u :: \\kappa). \\tau \\qquad \\Delta \\vdash c :: \\kappa }{   \\Delta \\, \\Gamma \\vdash e[c] : [c/u]\\tau }\\]  The math is rendered with [\\(\\KaTeX\\)][katex]. If a page uses math, Pandoc will automatically include the necessary CSS and JavaScript files to render the math.  [katex]: https://katex.org/  Images, tables, and captioned code blocks  Pandoc Markdown has special syntax for images and tables, and their captions. For example:    !  Note how the image's  text became the caption. With tables, the syntax is slightly different:  | Column 1       | Column 2       | |  |  | | This is some text. | This is some text. | | This is some text. | This is some text. |  Table: This is the caption.  On top of the syntax Pandoc Markdown provides, this theme supports attaching captions to code blocks by wrapping the code block in a  tag.  ruby source 'https://rubygems.org'  gem 'sorbet' gem 'sorbet-runtime' `  <figure>  <figcaption>An example Gemfile</figcaption> </figure>  Wide, extra-wide, and full-width  As mentioned when discussing side notes, this theme aims to be fully responsive. Responsive means more than just making it work on mobile—it means making the most of the available space on both small and large screens.  To help you make the most of the available space, this theme provides three utility classes to declare how much extra space to use up when available:  -    - On smaller screens, sets .   - Takes up to  space,[^main-width] potentially expanding into     the margin to do so. For example: when the browser takes up half of a     1920x1080 screen. -    - From : on smaller screens, sets .   - Takes up to  space,[^extra-wide-factor] potentially     expanding into the margin to do so.   - If the right margin is not collapsed, the content will expand equally into     both margins and be centered. -    - From : on smaller screens, sets .   - Take up all available space, expanding into all margins.  [^main-width]: {-} The  CSS variable defaults to 745px.  [^extra-wide-factor]:   {-} This multiple is configurable with .  (Note that  and  only work in conjunction with .)  These classes work with images, tables, code blocks, and math. Here are some examples:  :::{.wide .extra-wide}  | Column 1       | Column 2       | Column 3       | Column 4       | Column 5       | Column 6       | Column 7       | Column 8       | |  |  |  |  |  |  |  |  | | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. | | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. | This is some text. |  :::  :::{.wide .full-width .left-align-caption} ! :::  <figure class=\"wide extra-wide\"> \\[   \\frac{\\quad}{\\Delta \\, \\Gamma , x \\, : \\, \\tau \\vdash x \\, : \\, \\tau} \\;   (16.2a)   \\quad \\frac{\\Delta \\vdash \\tau_1 \\, \\textsf{type} \\quad \\Delta \\, \\Gamma , x \\, : \\, \\tau_1 \\vdash e \\, : \\, \\tau_2}{\\Delta \\, \\Gamma \\vdash \\texttt{lam}\\{\\tau_1\\}(x.e) \\, : \\, \\texttt{arr}(\\tau_1; \\tau_2)} \\; (16.2b)   \\quad \\frac{\\Delta \\, \\Gamma \\vdash e_1 \\, : \\, \\texttt{arr}(\\tau_2 ; \\tau) \\quad \\Delta \\, \\Gamma \\vdash e_2 \\, : \\, \\tau_2}{\\Delta \\, \\Gamma \\vdash \\texttt{ap}(e_1 ; e_2) \\, : \\, \\tau} \\; (16.2c) \\\\    \\, \\\\   \\quad \\frac{\\Delta, t \\, \\textsf{type} \\, \\Gamma \\vdash e \\, : \\, \\tau}{\\Delta \\, \\Gamma \\vdash \\texttt{Lam}(t.e) \\, : \\, \\texttt{all}(t.\\tau)} \\; (16.2d)   \\quad \\frac{\\Delta \\, \\Gamma \\vdash e \\, : \\, \\texttt{all}(t.\\tau') \\quad \\Delta \\vdash \\tau \\, \\textsf{type}}{\\Delta \\, \\Gamma \\vdash \\texttt{App}\\{\\tau\\}(e) \\, : \\, [\\tau / t]\\tau'} \\; (16.2e) \\] <figcaption>Typing rules for System F, From PFPL Chapter 16</figcaption> </figure>  :::{.wide}    :::  (There is currently a bug where using  with  code blocks causes the line numbers to be hidden. They are still highlightable and linkable.)  There are two supported syntaxes for marking things wide:  - Using Pandoc's  feature.            This is convenient when not using captions, or when using the     special-purpose caption syntax for images and tables.  - Using a raw  tag.            Code blocks and display-mode math don't have special syntax for adding captions, so this is the only option then.  On large screens, the captions will generally be center aligned. This can look strange, especially for captions whose text wraps onto multiple lines. To avoid centering captions, add the .  :::{.note .blue} |     | |  | | ℹ️ You probably want to wrap all math and tables in  unless they're less than ~300px. It will never display wider than the main body, but the  property on  ensures that it scrolls just the figure, not the whole page body. |  :::  Colored note callouts  As you just saw, an extra feature of this theme is colored note callouts. The syntax takes advantage of Pandoc's  feature:    :::{.note .blue} |     | |  | | ℹ️ This is a note. | :::  Right now, notes are implemented in terms of HTML tables. This may change in the future.  There are five colors total. The other colors:  :::{.note .red} |     | |  | | 🛑 Don't do it! |  :::  :::{.note .yellow} |     | |  | | ☢️ Warning! |  :::  :::{.note .green} |     | |  | | ✅ Nice job! |  :::  :::{.note .purple} |     | |  | | 🔮 Can you see the future? |  :::  In addition to full-width block callouts, there are also inline highlights, in the same colors: [red]{.mark .red}, [yellow]{.mark .yellow}, [green]{.mark .green}, [blue]{.mark .blue}, [purple]{.mark .purple}.  These accent colors are configurable with CSS variables.  Table of contents  As you might have noticed, there's an autogenerated table of contents! On large screens, it floats to the right margin. On narrower screens, it collapses into the document header.  This is powered by Pandoc's built in  flag. See where this project passes it to the  invocation [here][toc].  [toc]: https://github.com/jez/pandoc-markdown-css-theme/blob/27d0aa58bfc6eafe296e2cef1900a39c9c2507a7/tools/build.sh#L62  Tweaking the CSS variables  As mentioned multiple times above, this theme is very configurable. See [theme.css] for the full list of CSS variables. They control things like  - Font colors - Accent colors - Table borders and header colors - Font family - Font sizes, including body copy, code, and headings - Side note text sizes and alignment - The main width, including at narrow screen sizes.  As an example, see the  page, which tweaks these CSS variables to approximate the look of [Tufte CSS].  It's also easy to change the syntax theme used for code highlights, because it lives in a separate file. The default theme is Solarized Light, which can be found in [skylighting-solarized-theme.css].  [theme.css]: https://github.com/jez/pandoc-markdown-css-theme/blob/27d0aa58bfc6eafe296e2cef1900a39c9c2507a7/public/css/theme.css#L2  [skylighting-solarized-theme.css]: https://github.com/jez/pandoc-markdown-css-theme/blob/27d0aa58bfc6eafe296e2cef1900a39c9c2507a7/public/css/skylighting-solarized-theme.css#L1  Automatic light and dark theme  Pages will automatically choose light mode or dark mode styles based on the user's preferences, detected via CSS  queries.[^media]  You can also use the  and  CSS classes to make something appear only in light or dark mode. One use case for this is with images. For example, here's some Pandoc markdown using [] that shows a light or dark mode version of an image:  []: https://pandoc.org/MANUAL.html#extension-fenced_divs    Only one of those divs will be rendered, depending on which theme is active. You can see the result below, and you can toggle your light or dark mode theme to see how the image updates:  :::{.only-light-mode} ! :::  :::{.only-dark-mode} ! :::  [^media]:   At the moment, this means there is no way to programmatically toggle between   light and dark mode except by toggling the OS or browser's setting.  Print styles  As a reminder, this theme has custom print styles for U.S. Letter size paper. The print styles look similar to a somewhat narrow desktop screen, with enough room for a right margin with sidenotes, but not quite enough width to support the full 745px that the main body would normally take up. There is no large left margin, so the table of contents is shown at the top of the page (expanded).  If print styles matter to you, take care to make sure that things don't wrap. Some things like tables or math that would normally overflow and scroll on a screen will be clipped when printed. Always test your content before publishing.  Feel free to test on this page. The tables and math are wide enough to demonstrate the problems.  Most browsers will offer the user a choice of whether to include background colors or not. Things like code block backgrounds and table header backgrounds won't show up unless the browser's \"Print backgrounds\" option (or equivalent) is checked.", "url": "/articles/readme.html"}]